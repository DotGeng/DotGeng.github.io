<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[spring事务管理]]></title>
      <url>http://yoursite.com/2016/07/30/spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<p>一： 数据库事务的基本知识<br>    1.1何为数据库事务：多个SQL 语句，要么都执行失败要么都执行成功；<br>        数据库事务的4个特性：ACID<br>        原子性（automatic）<br>        一致性（consistency）<br>        隔离性（Isolation）<br>        持久性(durability)<br>    1.2数据库并发的问题<br>        三类数据度问题<br>        两类数据更新问题<br>        脏读：A事务读取B事务尚未提交的数据。并在这个数据的基础上操作。如果恰巧B事务回滚，那么A事务读到的数据根本不会被承认。<br>        不可重复读：A事务读取了B事务已经提交的更改数据，导致在A事务过程中两次被读到的数据结果不一致。<br>        幻象：A事务提交了B事务新增的数据，导致A事务过程两次读取的结果不一致。<br>            防止不可重复读：添加行级锁<br>            防止幻象读：添加表级锁，防止新增数据。<br>，第一类数据更新，第二类数据更新；<br>        第一类丢失更新：A事务撤销的时候把B事务的更新数据覆盖了；<br>        第二类丢失更新：A事务覆盖B事务提交过的数据，造成B事务所做造作的丢失。<br>    1.3数据库锁机制<br>        数据库并发会出现很多问题，数据库通过锁机制解决并发访问的问题。<br>        按照锁定的对象不同：行锁定  、 表锁定。<br>        按照并发事务关系开看，可分为共享锁定和独占锁定；<br>    1.4 事务的隔离级别<br>        数据库提供了自动锁机制。只要用户指定了事务的隔离级别，数据库就会自动为事务操作的数据资源添加合适的锁。此外数据库还会维护这些锁，当一个资源上的所属木太多的时，自动进行锁的升级以提高系统的运行性能，而这一过程对于用户来说是完全透明的。<br>一下是<br>隔离级别    脏读<br>不可重复读<br>幻象读<br>第一类丢失更新<br>第二类丢失更新<br>READ UNCOMMITED    允许    允许<br>允许<br>不允许    允许<br>READ COMMITED<br>不允许<br>允许<br>允许<br>不允许<br>允许<br>REPEATABLE READ<br>不允许<br>不允许<br>允许<br>不允许<br>不允许<br>SERILIZABLE<br>不允许<br>不允许<br>不允许<br>不允许<br>不允许<br>    1.5 JDBC对事务的支持<br>        并不是所有的数据库都支持事务，即使支持事务，也不见得会支持事务的所有隔离级别。用户可以根据Connection#getMetaData()方法获取DatabaseMetaData对象。并通过该对象的supportsTransaction（）、supportsTransactionIsolationLevel(int level) 来查看数据库对事务的支持情况。<br>    JDBC 事务代码：<br>            Connection conn;<br>            try {<br>                conn = DriverManager.getConnection();//1 获取数据库连接<br>                conn.setAutoCommit(false);//2 为了将多个sql语句当成一个事务执行，必须关闭connection的自动提交功能<br>                conn.setTransactionIsolation(Connection.TRANSACTION_SERIALIZABLE);//3 设置事务的隔离级别<br>                Statement stmt = connn.createStatement();<br>                int rows = stmt.executeUpdate(sql1);<br>                rows = stmt.executeupdate(sql2);<br>                    .<br>                    .<br>                  conn.commit();// 4 提交事务</p>
<pre><code>}catch（） {
     conn.rollback();//5 出现异常，事务回滚
 }finally{
 }
 保存点; 并不是所有的数据库都支持保存点功能，用户可以通过DatabaseMetaData#supportsSavepoints() 方法查看是否支持。
 savePoint 允许事务被分割成很多阶段，用户可以指定回滚事务的特定保存点。而并非像JDBC 2.0 那样 只能回滚到开始事务的点.
看下面的代码：就是回滚到指定的保存点，而不是事务开始的点。

 Statement stmt = connn.createStatement();
 int rows = stmt.executeUpdate(sql1);
 。。。
 Savepoint svpt = conn.setSavepoint(&quot;savePoint1&quot;); // 1 设置一个保存点
 rows = stmt.executeupdate(sql2);
 。。。
 conn.rollback(svpt);//2 回滚到1处的savePoint1， 1 之前的 操作事务提交后依旧提交，但是1和2 之间的sql操作被撤销了。
 。。。
 conn.commit();// 3 提交事务
</code></pre><p>二：ThreadLocal 在数据库事务方面的应用<br>    2.1 什么是ThreadLocal<br>        ThreadLocal 不是一个线程，而是线程的一个本地化对象。当工作于多线程使用ThreadLocal时，ThreadLocal为每一个线程分配一个独立的变量副本。所以每一个线程都可以独立的改变自己的副本，不会影响其他线程对应的副本。从线程的角度来看，这个线程就像线程的本地变量，这就是勒种的“Local”所要表达的意思。<br>    2.2 ThreadLocal的接口方法<br>            void set(Object value)<br>                设置当前线程局部变量的值；<br>            public Object get()<br>                该方法返回当前线程所对应的线程局部变量<br>            public void remove()<br>                将当前线程的局部变量的值删除，目的是减少内存的占用。需要指出的是，当线程结束后，该线程对应的局部变量会被自动回收，所以，显示调动该方法清除线程的局部变量不是必须的的操作，但是这可以加快内存回收的速度。<br>            protected Object initialValue()<br>                返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法。<br>            ThreadLocal现在已经支持泛型了。该类的类名现在已经变为ThreadLocal<t> 了。API 方法也相应进行了调整。新版的API 方法分别是void set(T value)、void get() 以及 T initValue().<br>            ThreadLocal 是如何做到为每一个线程维护一份独立的变量副本呢？其实很简单：在ThreadLocal类中有一个map对象，用于存储每一个线程的变量副本，Map中元素的键为线程对象，而值对应的就是变量的副本。甚至我们自己就可以写一个简单的ThreadLocal类（如果写博文的话，就把这个简单的类实现下）；<br>    2.3一个ThreadLocal实例<br>        下边我们通过一个实例具体了解一下ThreadLocal的使用的方法。</t></p>
<p>public class SequenceNumber {<br>    private static ThreadLocal<integer> seqNum = new ThreadLocal<integer>(){<br>        @Override<br>        protected Integer initialValue() {<br>            return 0;<br>        }<br>    };<br>    public int getNextNum() {<br>        seqNum.set(seqNum.get() +1);<br>        return seqNum.get();<br>    }<br>    public static void main(String[] args) {<br>        SequenceNumber sn = new SequenceNumber();//只需要实例化一次</integer></integer></p>
<pre><code>    TestClient t1 = new TestClient(sn);
    TestClient t2 = new TestClient(sn);
    TestClient t3 = new TestClient(sn);// 3个线程共享sn，各自产生序列号；

    t1.start();
    t2.start();
    t3.start();
}
</code></pre><p>}<br>class TestClient extends Thread {<br>    private SequenceNumber sn ;<br>    public TestClient(SequenceNumber sn) {<br>        this.sn = sn;<br>    }<br>    @Override<br>    public void run() {<br>        for(int i = 0 ; i &lt; 3 ; i ++) {<br>            System.out.println(“thread :[“ + Thread.currentThread() + “] sn[“<br>                    +sn.getNextNum() +”]”<br>                    );<br>        }<br>    }<br>}<br>输出结果是：</p>
<p>thread :[Thread[Thread-0,5,main]] sn[1]<br>thread :[Thread[Thread-0,5,main]] sn[2]<br>thread :[Thread[Thread-0,5,main]] sn[3]<br>thread :[Thread[Thread-1,5,main]] sn[1]<br>thread :[Thread[Thread-2,5,main]] sn[1]<br>thread :[Thread[Thread-1,5,main]] sn[2]<br>thread :[Thread[Thread-2,5,main]] sn[2]<br>thread :[Thread[Thread-1,5,main]] sn[3]<br>thread :[Thread[Thread-2,5,main]] sn[3]<br>    2.4 与Thread同步机制的比较<br>         ThreadLocal和线程都可以解决线多线程中相同变量的访问冲突问题，那么，这两者有什么区别呢？下边我们来一一解答。<br>            两者有什么区别？<br> 在同步机制中，通过对象锁机制，保证在某一个时刻，只能有一个线程对变量进行访问。这就要求程序编写者对多线程的并发操作有比较专业的认识，才能胜任此项工作。采用“时间换取空间”的方式，访问串行化，对象共享化；<br>而在ThreadLocal从另一个角度来解决多线程的并发问题。那就是为每一个变量复制一个副本，从而隔离了多个线程对数据的访问。这样启示我们，当遇到不安全的对象时候，就要考虑用ThreadLocal对象封装不安全的对象。采用”空间换取时间“的方式，访问并行化，对象独享化；<br>            那么要用那种方式更好，就依据实际情况而定，这里不做讨论，以后有机会再单独说。<br>    2.5 终于说到了主题, spring 就是使用ThreadLocal 来解决线程安全问题的。<br>        一般情况下只有无状态的Bean才可以在多线程的环境下共享。在Spring中，绝大数的Bean是可以声明为单例作用域的。就是因为Spring对一些Bean中非线程安全的“状态类对象”，采用ThreadLocal进行封装，让他们也成为了线程安全的“状态类对象”，因此有状态的Bean就能够以Singleton的方式在多线程中正常的工作了。<br>       下边的两个编程实例将展示Spring对有状态的bean的改造思路；</p>
<pre><code>public class TopicDao  {
    //conn是一个非线程安全的变量
    private Connection conn;
    public void addTopic() {
        //引用非线程安全变量
        Statement stat = conn.createStatement();
        ...
    }
}
由于conn是非线程安全的成员变量，因此addTopic()方法是非线程安全的，必须在使用的时候新建一个TopicDao实例（非SingleTon）。下面使用ThreadLocal对这个非线程安全的conn变量进行改造。
</code></pre><p>import java.sql.Connection;<br>import java.sql.SQLException;<br>import java.sql.Statement;</p>
<p>public class TopicDao {<br> //1.使用ThreadLocal变量对Connection变量进行封装。<br> private static  ThreadLocal<connection> connThreadLocal = new ThreadLocal<connection>();<br> public static Connection getConnection() {<br>//2 如果connThreadLocal 中没有本线程对应的conn,则创建一个新的conn，并且保存在connThreadLocal中<br>  if(connThreadLocal.get() == null) {<br>   Connection conn = ConnectionManager.getConnection();<br>   connThreadLocal.set(conn);<br>   return conn;<br>  }else {<br>//3 否则直接返回线程本地变量<br>   return connThreadLocal.get();<br>  }<br> }<br> public void addTopic() throws SQLException {<br>//4 从ThreadLocal中获取线程对应的执行语句<br>  Statement stat = getConnection().createStatement();<br> }<br>}<br>这个实例基本上说明了Spring对有状态类线程安全化的解决思路；<br>    3 Spring对事务管理的支持<br>        Spring对事物管理提供了一致的编程模板，在高层次上建立了统一的事物抽象。也就是说不管选择Spring JDBC、Hibernate、JPA还是Mybatis，Spring都让我们可以使用统一的编程模型进行事务管理。<br>    3.1 事物管理关键抽象<br>        在spring书屋管理SPI（Service Provider Interface）的抽象层主要包括三个接口，分别是PlatformTransactionManager，TransactionDefinition和TransactionStatus，他们位于org.springframework.transaction包中。<br>        TransactionDefinition用于描述事务的隔离级别，超时时间，是否为只读事务和事务传播规则等控制控制事务具体行为的事务属性，这行事务属性可以通过xml配置或者注解进行配置，也可以通过手动编程的方式设置。<br>        TransactionManager 根据TransactionDefinition提供的事务配置信息，创建事务，并用TransactionStatus描述这个激活事务的状态，下面，我们分别来了解下这些SPI接口内部的组成；<br>        TransactionDefinition<br>            定义Spring的事务属性，这些属性从若干方面进行配置；<br>事务隔离:请参考前边讲解的几种隔离级别，另外Spring增加了一种默认的事务隔离级别；ISOLATUION_DEFAULT，他表示使用底层数据库默认的隔离级别；<br>事务传播:当我们调用一个基于Spring的Service接口方法时，他将运行于Spring管理的事务环境中，Service接口方法可能会在内部调用其他的service接口方法来完成一个完整的业务操作。这就是service接口嵌套调用的情形。Spring通过事务传播行为控制当前的事务如何传播到被嵌套调用的目标服务调用接口方法中。事务传播行为非常的重要，也是误解最多的地方，这里先介绍这里，后边我们进行更为详细的讲述；<br>事务超时：事务在超时之前运行，当超过时间后，就会进行事务的回滚；另外，有些事务管理器是不支持事务事务过期的功能的。<br>只读状态：只读事务是不能进行数据修改的。<br>            Spring允许通过XML或注解的方式进行事务的属性配置，这些信息作为事务管理框架的输入，Spring将按照这些属性信息的指示，创建对应的事务。<br>        TransactionStatus<br>            代表事务的具体运行状态。事务管理器通过该接口获取事务的运行的状态信息。也可以通过该接口间接的回滚事务，他相比于在在抛出异常的时候回滚事务更具可控性。该接口继承SavepointManager接口。SavepointManager接口是基于JDBC3.0保存点的分段事务控制能力提供了嵌套事务的机制。<br>        Object createSavePoint()<br>            创建一个保存点对象；<br>        void rollbackToSavePoint(Object savepoint)<br>            回滚事务到指定的保存点；<br>        void releaseSavePoint(Object savepoint)<br>             释放一个保存点；如果事务提交，该保存点自动释放，不需要手动释放；<br>        有时候底层的资源不支持保存点，就会抛出异常。<br>    未完待续。。。</connection></connection></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[字节流和字符流的区别]]></title>
      <url>http://yoursite.com/2016/07/29/%E5%AD%97%E8%8A%82%E6%B5%81%E5%92%8C%E5%AD%97%E7%AC%A6%E6%B5%81%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>字符流的由来：因为数据编码的不同，而有了对字符进行高效操作的流对象，本质就是对基本的字节流读取数据时，去查了指定的码表。字节流和字符流的区别：<br>1 读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表的映射字符，一次可以读取多个字节。<br>2 处理对象不同：字节流能处理所有类型的数据（如图片和视频等）。但是字符流只能处理字符类型的数据。<br>3 字节流继承自InputStream OutputStream<br>   字符流继承自InputStreamReader OutputStramWriter<br>4 字节流使用了缓冲区，而字符流没有使用缓冲区<br>5 字符是字节通过不同编码的封装。<br>6 字节流字符流像字节流转换的时，要注意编码</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[面向对象开发的六个基本原则，并且在项目中用过哪些原则？]]></title>
      <url>http://yoursite.com/2016/06/22/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%BC%80%E5%8F%91%E7%9A%84%E5%85%AD%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%EF%BC%8C%E5%B9%B6%E4%B8%94%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%94%A8%E8%BF%87%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%88%99%EF%BC%9F/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[面向对象和面向过程的区别？面向过程可以实现面向对象吗？]]></title>
      <url>http://yoursite.com/2016/06/21/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%90%97%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>面向对象和面向过程的区别？<br>    1 面向过程是一个细心的管家，事无巨细都要考虑到，而面向对象就像是一个家用电器，不需要知道他的实现原理，只需要知道他的功能有哪些，以及怎么使用这些功能即可；<br>    2 面向过程是以事件为中心的编程思想，就是要分析出解决问题的思路，然后用函数吧这些过程都实现，然后按照顺序调用即可。面向对象是以“对象”为中心的编程思想。<br>    3 举一个简单的例子：汽车发动和汽车到站<br>        对于面向过程来说，汽车到站和汽车出站都是事件面向过程是以事件为中心的编程思想，面向过程就把汽车发动和汽车到站设置为两个函数，然后依次调用即可。<br>        面向过程是以对象为中心的编程思想，他关注的是汽车本身这个对象，包括这个汽车有哪些功能，哪些属性，如汽车的功能是发动，行驶，而对于具体事件，是否是出发或者到站，        在对象的设计中并不考虑。只有在处理业务的时候，才会涉及到事件。<br>    面向过程可以实现面向对象吗？<br>    在我看来，这是两种不同的思想，在思想层面上不存在谁去实现谁。但是就代码实习的功能来说，肯定是面向过程可以实现面向对象的功能，而且面向对象编程也可以实现面向过程的功能；</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java的四个特性（抽象，封装，继承，多态），对多态使用方式的理解]]></title>
      <url>http://yoursite.com/2016/06/20/java%E7%9A%84%E5%9B%9B%E4%B8%AA%E7%89%B9%E6%80%A7%EF%BC%88%E6%8A%BD%E8%B1%A1%EF%BC%8C%E5%B0%81%E8%A3%85%EF%BC%8C%E7%BB%A7%E6%89%BF%EF%BC%8C%E5%A4%9A%E6%80%81%EF%BC%89%EF%BC%8C%E5%AF%B9%E5%A4%9A%E6%80%81%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>1 java的四个基本特性：</p>
<pre><code>● 抽象

    抽象：将一类事物的共同特征抽象出来，并进行类的设计和创建。抽象包括数据抽象和行为抽象，比如：犬类有年龄名字等属性，这种特征抽象出来就是数据抽象，所有的狗都有叫的行为，这种抽象成为一种方法，这种抽象就是行为抽象。抽象只关注对象有那些属性和行为，并不关注有这些行为的细节是什么。

● 封装

    封装：通常认为是把数据和操作数据的方法封装起来，对数据的访问，只能通过已定义的方法。面向对象的本质就是将现实世界描绘成一系列完全自制、封闭的对象。我们在类中编写的方法，就是对实现细节的一些封装。我们编写的一个类就是对数据或者数据操作的封装。可以说封装就是隐藏一切可以隐藏的东西，只向外界提供最简单的编程接口。

● 继承

    继承：继承就是从已有的类中继承信息，并创建新类的过程。被继承的类称之为父类，基类或者超类，得到继承信息的类称为子类或者派生类。继承让变化中的软件系统有了一定的延续性，同时继承也是封装可变因素的重要手段（日后解释，今天这里不是重点）。

● 多态

    多态：对不同子类型的对象对同一消息做出不同的回应。
</code></pre><p>2 多态的理解（多态的实现方式）：<br>        实现多态，必须实现以下的三个条件，缺一不可：继承，重载，父类引用指向子类对象。</p>
<p>3<br>  项目中对多态的使用：例如我写的一个在心预约考试系统里边，有未预约的用户，和已经预约过的用户。这两种用户都能登录系统，但是登录系统显示的是不同的界面，这就是他们分别继承了用户的类，分别重载了父类login方法。在用户登录的时候，就对不同的用户对象进行不同的操作。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java中Class对象详解(转载)]]></title>
      <url>http://yoursite.com/2016/05/16/java%E4%B8%ADClass%E5%AF%B9%E8%B1%A1%E8%AF%A6%E8%A7%A3-%E8%BD%AC%E8%BD%BD/</url>
      <content type="html"><![CDATA[<p> java中把生成Class对象和实例对象弄混了，更何况生成Class对象和生成instance都有多种方式。所以只有弄清其中的原理，才可以深入理解。首先要生成Class对象，然后再生成Instance。那Class对象的生成方式有哪些呢，以及其中是如何秘密生成的呢？<br> &lt;–more–&gt;<br>Class对象的生成方式如下：<br>1.Class.forName(“类名字符串”)  （注意：类名字符串必须是全称，包名+类名）<br>2.类名.class<br>3.实例对象.getClass()<br>通过一段小程序，来观察一下Class对象的生成的原理。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">public class TestClass &#123;  </span><br><span class="line">  </span><br><span class="line">   </span><br><span class="line">  </span><br><span class="line">public  static void main(String[] args)  </span><br><span class="line">  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line">try &#123;  </span><br><span class="line">  </span><br><span class="line">//测试Class.forName()  </span><br><span class="line">  </span><br><span class="line">Class <span class="built_in">test</span>TypeForName=Class.forName(<span class="string">"TestClassType"</span>);          </span><br><span class="line">  </span><br><span class="line">System.out.println(<span class="string">"testForName---"</span>+<span class="built_in">test</span>TypeForName);  </span><br><span class="line">  </span><br><span class="line">//测试类名.class  </span><br><span class="line">  </span><br><span class="line">Class <span class="built_in">test</span>TypeClass=TestClassType.class;  </span><br><span class="line">  </span><br><span class="line">System.out.println(<span class="string">"testTypeClass---"</span>+<span class="built_in">test</span>TypeClass);  </span><br><span class="line">  </span><br><span class="line">//测试Object.getClass()  </span><br><span class="line">  </span><br><span class="line">TestClassType <span class="built_in">test</span>GetClass= new TestClassType();  </span><br><span class="line">  </span><br><span class="line">System.out.println(<span class="string">"testGetClass---"</span>+<span class="built_in">test</span>GetClass.getClass());  </span><br><span class="line">  </span><br><span class="line">   </span><br><span class="line">  </span><br><span class="line">&#125; catch (ClassNotFoundException e) &#123;  </span><br><span class="line">  </span><br><span class="line">// TODO Auto-generated catch block  </span><br><span class="line">  </span><br><span class="line">e.printStackTrace();  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">   </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"> class TestClassType&#123;  </span><br><span class="line">  </span><br><span class="line">//构造函数  </span><br><span class="line">  </span><br><span class="line">public <span class="function"><span class="title">TestClassType</span></span>()&#123;  </span><br><span class="line">  </span><br><span class="line">System.out.println(<span class="string">"----构造函数---"</span>);  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">//静态的参数初始化  </span><br><span class="line">  </span><br><span class="line">static&#123;  </span><br><span class="line">  </span><br><span class="line">System.out.println(<span class="string">"---静态的参数初始化---"</span>);  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">//非静态的参数初始化  </span><br><span class="line">  </span><br><span class="line">&#123;  </span><br><span class="line">  </span><br><span class="line">System.out.println(<span class="string">"----非静态的参数初始化---"</span>);  </span><br><span class="line">  </span><br><span class="line">&#125;          </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试的结果如下：<br>—静态的参数初始化—<br>testForName—class TestClassType<br>testTypeClass—class TestClassType<br>—-非静态的参数初始化—<br>—-构造函数—<br>testGetClass—class TestClassType</p>
<p>根据结果可以发现，三种生成的Class对象一样的。并且三种生成Class对象只打印一次“静态的参数初始化”。<br>我们知道，静态的方法属性初始化，是在加载类的时候初始化。而非静态方法属性初始化，是new类实例对象的时候加载。<br>因此，这段程序说明，三种方式生成Class对象，其实只有一个Class对象。在生成Class对象的时候，首先判断内存中是否已经加载。<br>所以，生成Class对象的过程其实是如此的：<br>当我们编写一个新的Java类时,JVM就会帮我们编译成class对象,存放在同名的.class文件中。在运行时，当需要生成这个类的对象，JVM就会检查此类是否已经装载内存中。若是没有装载，则把.class文件装入到内存中。若是装载，则根据class文件生成实例对象。</p>
<p>转载自——<a href="http://blog.csdn.net/yuebinghaoyuan/article/details/7244123" target="_blank" rel="external">http://blog.csdn.net/yuebinghaoyuan/article/details/7244123</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[hexo博客被百度+google收录的方法]]></title>
      <url>http://yoursite.com/2016/05/09/hexo%E5%8D%9A%E5%AE%A2%E8%A2%AB%E7%99%BE%E5%BA%A6-google%E6%94%B6%E5%BD%95%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>我自己的hexo博客搭建起来也好多天了，但是一直没有办法被别人检索到，这样总觉得不好装逼，别人看不到啊。于是，决定花一天时间来搞下。<br>博客，是我们技术人员向外界展示自己思想的重要途径，也是和志同道合的人来交流的一个很好的平台，但是如果我们的博客不能被百度和google检索到，那就好像是我们自己在家里造车，造好之后，从不把它拉到市场上，只是放在家里。那么今天我就分享下我是怎么把我的”车”拉到市场上的。<br><a id="more"></a></p>
<p>因为我在这个工程中走了很多弯路，导致我没少耗费时间，在这里我就写的尽量详细一点，为后来的小伙伴节省一点宝贵的时间。</p>
<p>1 我们需要买域名，我是在阿里云上买的域名，我就说下我买域名的过程。<br>  1.1 首先我们注册一个阿里云的账户(阿里云官网：<a href="https://www.aliyun.com/" target="_blank" rel="external">https://www.aliyun.com/</a>)<br>  1.2 在阿里云的主页上点击万网，如下图：<br>  <img src="/images/serachByGoogleOrBaidu/1.1.PNG" alt=""><br>  可以根据官网提示购买域名，这里不再赘述。<br>  1.3 下边怎么介绍怎么把域名指向自己的hexo博客网站。<br>    请参考<a href="https://help.aliyun.com/knowledge_detail/6555838.html?spm=5176.2020520130.105.2.sE5fR3&amp;&amp;msctype=pmsg&amp;mscmsgid=116416032500061222&amp;" target="_blank" rel="external">阿里云官方文档</a>;</p>
<p>2 第一步生效后，我们在浏览器中输入我们的域名，就能看到我们的hexo博客。那么接下来就是怎么让百度和google收录了。<br>    2.1 先确认博客是否被收录<br>        在百度或者谷歌上面输入下面格式来判断，如果能搜索到就说明被收录，否则就没有，用你的域名替代我的dotdotcloud.cn<br>        <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:dotdotcloud.cn</span><br></pre></td></tr></table></figure></p>
<p>   请看下边的图片：<br>   <img src="/images/serachByGoogleOrBaidu/2.1.png" alt=""> ；<br>   这里百度没有收录我的，因为github已经对百度爬虫是拒绝的，所以我这里还是介绍下以前用方法，为以后在这个方法的扩展而被百度收录做铺垫。如下图：<br>   <img src="/images/serachByGoogleOrBaidu/2.1.2.png" alt=""></p>
<p>   2.2 验证网站<br>      <a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="external">google搜索引擎入口</a><br>      [百度搜索引擎入口]（<a href="http://zhanzhang.baidu.com/linksubmit/url）" target="_blank" rel="external">http://zhanzhang.baidu.com/linksubmit/url）</a><br>      下载此HTML验证文件。[google0b4c8a25b65d7c2a.html]<br>      将文件上传到 <a href="http://yoursite/" target="_blank" rel="external">http://yoursite/</a><br>      通过浏览器访问： <a href="http://yoursite/google0b4c8a25b65d7c2a.html" target="_blank" rel="external">http://yoursite/google0b4c8a25b65d7c2a.html</a> 确认上传成功。<br>      点击下面的“验证”。<br>      为了保证已进行了验证的状态，及时通过了验证也不要删除该html文件。<br>      我们的博客系统使用了hexo，部署在Github上，因此下载Google的验证文件之后，需要在文件开头添加layout: false来取消hexo对其进行的转换，如下：<br>            <img src="/images/serachByGoogleOrBaidu/2.2.1.png" alt=""><br>            不管谷歌还是百度都要先添加域名，然后验证网站，这里统一都使用文件验证，就是下载对应的html文件，放到域名根目录下，也就收博客根目录下的source下面<br>             <img src="/images/serachByGoogleOrBaidu/2.2.2.png" alt=""><br>            然后部署到服务器,输入地址：<a href="http://tengj.top/googlead0e22632f59a368.html" target="_blank" rel="external">http://tengj.top/googlead0e22632f59a368.html</a> 能访问到内容就可以点验证按钮。<br>            站点地图：<br>          站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。Googlebot等搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站。<br>        我们要先安装一下，打开你的hexo博客根目录，分别用下面两个命令来安装针对谷歌和百度的插件<br>        npm install hexo-generator-sitemap –save<br>        npm install hexo-generator-baidu-sitemap –save<br>         在博客目录的_config.yml中添加如下代码(我不加也可以)<br>         自动生成sitemap：<br>         sitemap:<br>         path: sitemap.xml<br>         baidusitemap:<br>         path: baidusitemap.xml<br>       编译你的博客<br>       <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure></p>
<p>   如果你在你的博客根目录的public下面发现生成了sitemap.xml以及baidusitemap.xml就表示成功了。<br>         这时候sitemap.xml跟baidusitemap.xml里面的内容一样，但是文章链接都是tengj.github.io的，这里我就很奇怪了，我博客同时对应github和coding的，为啥生成的sitemap.xml对应的域名都是yoursite.com，所以我把里面的改成了我的个人域名dotdotclodu .cn。<br>   部署后你分别访问<br>     <a href="http://dotdotcloud.cn/sitemap.xml" target="_blank" rel="external">http://dotdotcloud.cn/sitemap.xml</a><br>   <a href="http://dotdotcloud.cn/baidusitemap.xml" target="_blank" rel="external">http://dotdotcloud.cn/baidusitemap.xml</a><br>   <img src="/images/serachByGoogleOrBaidu/2.2.3.png" alt=""><br>   <img src="/images/serachByGoogleOrBaidu/2.2.4.png" alt=""><br>   让谷歌收录我们的博客:<br>   谷歌操作比较简单，就是向Google站长工具提交sitemap<br>    登录Google账号，添加了站点验证通过后，选择站点，之后在抓取——站点地图中就能看到添加/测试站点地图，如下图：<br>     <img src="/images/serachByGoogleOrBaidu/2.2.5.png" alt=""><br>     谷歌我提交过了两个小时就能搜索到我的博客了，效率很高。<br>     让百度收录我们的博客：<br>    谷歌很好搞定，百度就感觉很难，我从提交百度到现在写这篇博客，在百度那边也只能搜索到一条我的博客，真不容易。<br>    正常情况，是要等百度爬虫来爬到你的网站，才会被收录。<br>    但是github屏蔽了百度爬虫目前，所以我们要主动出击，我们自己把网站提交给百度。<br>    这就要使用到百度站长平台（<a href="http://zhanzhang.baidu.com/）" target="_blank" rel="external">http://zhanzhang.baidu.com/）</a><br>    验证网站<br>    验证网站最上面提过了，这里直接截图<br>     <img src="/images/serachByGoogleOrBaidu/2.2.6.png" alt=""><br>     <img src="/images/serachByGoogleOrBaidu/2.2.7.png" alt=""><br>    网页抓取：<br>    上面步骤成功后，进入站点管理，找到网页抓取这边详情点进去<br>    <img src="/images/serachByGoogleOrBaidu/2.2.8.png" alt=""><br>    我们主动提交博客文章链接<br>    如何选择链接提交方式<br>        1、主动推送：最为快速的提交方式，推荐您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。<br>        2、自动推送：最为便捷的提交方式，请将自动推送的JS代码部署在站点的每一个页面源代码中，部署代码的页面在每次被浏览时，链接会被自动推送给百度。可以与主动推送配合使用。<br>        3、sitemap：您可以定期将网站链接放到sitemap中，然后将sitemap提交给百度。百度会周期性的抓取检查您提交的sitemap，对其中的链接进行处理，但收录速度慢于主动推送。<br>        4、手动提交：一次性提交链接给百度，可以使用此种方式。<br>        一般主动提交比手动提交效果好，这里介绍主动提交的两种方法<br>    从效率上来说：<br>            主动推送&gt;自动推送&gt;sitemap<br>            主动推送(最复杂，这里不做说明)；<br>            自动推送：<br>            自动推送很简单，就是在你代码里面嵌入自动推送JS代码，在页面被访问时，页面URL将立即被推送给百度<br>                代码如下：<br>                我是放在\themes\jacman\layout_partial\after_footer.ejs中，添加到下面就行。<br>              sitemap提交:<br>              <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> &lt;script&gt;</span><br><span class="line">	(<span class="function"><span class="title">function</span></span>()&#123;</span><br><span class="line">	var bp = document.createElement(<span class="string">'script'</span>);</span><br><span class="line">	    bp.src = <span class="string">'//push.zhanzhang.baidu.com/push.js'</span>;</span><br><span class="line">	    var s = document.getElementsByTagName(<span class="string">"script"</span>)[0];</span><br><span class="line">	    s.parentNode.insertBefore(bp, s);</span><br><span class="line">	&#125;)();</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<pre><code>        我这里是报的抓取失败的错误。
参考博客：http://www.jianshu.com/p/619dab2d3c08
                    http://selfboot.cn/2014/12/21/add_blog_to_google/
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[gc日志查看（转载）]]></title>
      <url>http://yoursite.com/2016/04/27/gc%E6%97%A5%E5%BF%97%E6%9F%A5%E7%9C%8B%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>Java GC类型</p>
<p>Java中的GC有哪几种类型？</p>
<p>参数<br>描述<br>UseSerialGC<br>虚拟机运行在Client模式的默认值，打开此开关参数后，<br>使用Serial+Serial Old收集器组合进行垃圾收集。<br>UseParNewGC<br>打开此开关参数后，使用ParNew+Serial Old收集器组合进行垃圾收集。<br>UseConcMarkSweepGC<br>打开此开关参数后，使用ParNew+CMS+Serial Old收集器组合进行垃圾收集。Serial Old作为CMS收集器出现Concurrent Mode Failure的备用垃圾收集器。<br>UseParallelGC<br>虚拟机运行在Server模式的默认值，打开此开关参数后，使用Parallel Scavenge+Serial Old收集器组合进行垃圾收集。<br>UseParallelOldGC<br>打开此开关参数后，使用Parallel Scavenge+Parallel Old收集器组合进行垃圾收集。<br><a id="more"></a></p>
<p>在Java程序启动完成后，通过jps观察进程来查询到当前运行的java进程，使用<br>Java代码  收藏代码<br>jinfo –flag UseSerialGC 进程  </p>
<p>的方式可以定位其使用的gc策略，因为这些参数都是boolean型的常量，如果使用该种gc策略会出现＋号，否则－号。</p>
<p>使用-XX:+上述GC策略可以开启对应的GC策略。</p>
<p>GC日志查看</p>
<p>可以通过在java命令种加入参数来指定对应的gc类型，打印gc日志信息并输出至文件等策略。</p>
<p>GC的日志是以替换的方式(&gt;)写入的，而不是追加(&gt;&gt;)，如果下次写入到同一个文件中的话，以前的GC内容会被清空。</p>
<p>对应的参数列表<br>Java代码  收藏代码<br>-XX:+PrintGC 输出GC日志<br>-XX:+PrintGCDetails 输出GC的详细日志<br>-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）<br>-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）<br>-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息<br>-Xloggc:../logs/gc.log 日志文件的输出路径  </p>
<p>这里使用如下的参数来进行日志的打印：<br>Java代码  收藏代码<br>-XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:./gclogs  </p>
<p>对于新生代回收的一行日志，其基本内容如下：<br>Java代码  收藏代码<br>2014-07-18T16:02:17.606+0800: 611.633: [GC 611.633: [DefNew: 843458K-&gt;2K(948864K), 0.0059180 secs] 2186589K-&gt;1343132K(3057292K), 0.0059490 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]  </p>
<p>其含义大概如下：<br>Java代码  收藏代码<br>2014-07-18T16:02:17.606+0800（当前时间戳）: 611.633（时间戳）: [GC（表示Young GC） 611.633: [DefNew（单线程Serial年轻代GC）: 843458K（年轻代垃圾回收前的大小）-&gt;2K（年轻代回收后的大小）(948864K（年轻代总大小）), 0.0059180 secs（本次回收的时间）] 2186589K（整个堆回收前的大小）-&gt;1343132K（整个堆回收后的大小）(3057292K（堆总大小）), 0.0059490 secs（回收时间）] [Times: user=0.00（用户耗时） sys=0.00（系统耗时）, real=0.00 secs（实际耗时）]  </p>
<p>老年代回收的日志如下：<br>Java代码  收藏代码<br>2014-07-18T16:19:16.794+0800: 1630.821: [GC 1630.821: [DefNew: 1005567K-&gt;111679K(1005568K), 0.9152360 secs]1631.736: [Tenured:<br>2573912K-&gt;1340650K(2574068K), 1.8511050 secs] 3122548K-&gt;1340650K(3579636K), [Perm : 17882K-&gt;17882K(21248K)], 2.7854350 secs] [Times: user=2.57 sys=0.22, real=2.79 secs]  </p>
<p>gc日志中的最后貌似是系统运行完成前的快照：<br>Java代码  收藏代码<br>Heap<br> def new generation   total 1005568K, used 111158K [0x00000006fae00000, 0x000000073f110000, 0x0000000750350000)<br>  eden space 893888K,  12% used [0x00000006fae00000, 0x0000000701710e90, 0x00000007316f0000)<br>  from space 111680K,   3% used [0x0000000738400000, 0x000000073877c9b0, 0x000000073f110000)<br>  to   space 111680K,   0% used [0x00000007316f0000, 0x00000007316f0000, 0x0000000738400000)<br> tenured generation   total 2234420K, used 1347671K [0x0000000750350000, 0x00000007d895d000, 0x00000007fae00000)<br>   the space 2234420K,  60% used [0x0000000750350000, 0x00000007a2765cb8, 0x00000007a2765e00, 0x00000007d895d000)<br> compacting perm gen  total 21248K, used 17994K [0x00000007fae00000, 0x00000007fc2c0000, 0x0000000800000000)<br>   the space 21248K,  84% used [0x00000007fae00000, 0x00000007fbf92a50, 0x00000007fbf92c00, 0x00000007fc2c0000)<br>No shared spaces configured.  </p>
<p>GC日志的离线分析</p>
<p>可以使用一些离线的工具来对GC日志进行分析，比如sun的gchisto(<a href="https://java.net/projects/gchisto)，gcviewer（https://github.com/chewiebug/GCViewer" target="_blank" rel="external">https://java.net/projects/gchisto)，gcviewer（https://github.com/chewiebug/GCViewer</a> ），这些都是开源的工具，用户可以直接通过版本控制工具下载其源码，进行离线分析。</p>
<p>下面就已gcviewer为例，简要分析一下gc日志的离线分析，gcviewer源代码工程是maven结构的，可以直接用maven进行package，这里编译的是1.34版本，本版本的快照已经上传至附件中。</p>
<p>需要说明的是，gcviewer支持多种参数生成的gc日志，直接通过java –jar的方式运行，加载生成的gc日志即可：<br>!{](/images/gcLog.png)</p>
<p>转自：<a href="http://brandnewuser.iteye.com/blog/2101501" target="_blank" rel="external">http://brandnewuser.iteye.com/blog/2101501</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java多线程编程中join方法]]></title>
      <url>http://yoursite.com/2016/04/26/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E4%B8%ADjoin%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>一 方法joinde 作用是所属的线程对象x正常执行run()方法中的任务，而使当前的线程z进行无限期的阻塞，等待线程x销毁后在继续执行线程z后边的代码。<br>    方法join具有是线程排队运行的作用，有些类似同步的运行效果。join和synchronized的区别是：join在内部使用的wait方法运行等待，而synchronized关键字使用的是“对象监视器”原理作为同步的。</p>
<p>二 当运行join方法时候，因为join底层使用的是wait方法，所以，当其被interrupt时候，就会报interruptedException异常。</p>
<p>三 方法join（long） 的作用<br>    使主程序在此处等待子程序运行执行时候后，主程序不在等待，继续往下执行。他和sleep(long) 方法有什么区别呢？ 区别主要就是同步的处理上，请接着往下看。</p>
<p>四 方法 join(long) 和 sleep(long)的区别<br>    方法join(long) 具有释放锁的特点（因为其底层是用wait实现的），然而sleep(long) 不会释放锁。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[通过管道进行线程间的通信:字符流]]></title>
      <url>http://yoursite.com/2016/04/25/%E9%80%9A%E8%BF%87%E7%AE%A1%E9%81%93%E8%BF%9B%E8%A1%8C%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1-%E5%AD%97%E7%AC%A6%E6%B5%81/</url>
      <content type="html"><![CDATA[<p>在管道通信通信中还可以传递字符流（字节流请看：通过管道进行线程间的通信:字符流）。</p>
<a id="more"></a>
<p>WriteData.java 代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package service;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PipedWriter;</span><br><span class="line"></span><br><span class="line">public class WriteData &#123;</span><br><span class="line">	public void writeMethod(PipedWriter out) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			System.out.println(<span class="string">"write:"</span>);</span><br><span class="line">			<span class="keyword">for</span>(int i = 0 ;i &lt; 3000; i ++) &#123;</span><br><span class="line">				String outData = <span class="string">""</span> + (i + 1);</span><br><span class="line">				out.write(outData);//往输出管道输出数据，所以用PipedOutputStream</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">			out.close();</span><br><span class="line">		&#125;catch(IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ReadData.java代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package service;</span><br><span class="line"></span><br><span class="line">import java.io.PipedReader;</span><br><span class="line"></span><br><span class="line">public class ReadData &#123;</span><br><span class="line">	public void <span class="built_in">read</span>Method(PipedReader input) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			System.out.println(<span class="string">"read:"</span>);</span><br><span class="line">			char[] byteArray = new char[20];</span><br><span class="line">			byteArray[0] = 1;</span><br><span class="line">			int <span class="built_in">read</span>Length = input.read(byteArray);//从管道流中读取数据，如果管道流中没有数据，那么这个方法阻塞</span><br><span class="line">			<span class="keyword">while</span>(<span class="built_in">read</span>Length != -1) &#123;</span><br><span class="line">				String newData = new String(byteArray, 0, <span class="built_in">read</span>Length);</span><br><span class="line">				System.out.println(newData);</span><br><span class="line">				<span class="built_in">read</span>Length = input.read(byteArray);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">			input.close();</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ThreadWriter.java代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package exthread;</span><br><span class="line"></span><br><span class="line">import java.io.PipedWriter;</span><br><span class="line"></span><br><span class="line">import service.WriteData;</span><br><span class="line"></span><br><span class="line">public final class ThreadWrite extends Thread&#123;</span><br><span class="line">	private WriteData write;</span><br><span class="line">	private PipedWriter out;</span><br><span class="line">	public ThreadWrite(WriteData write, PipedWriter out) &#123;</span><br><span class="line">		this.write = write;</span><br><span class="line">		this.out = out;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">		write.writeMethod(out);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ThreadRead.java 代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package exthread;</span><br><span class="line"></span><br><span class="line">import java.io.PipedInputStream;</span><br><span class="line">import java.io.PipedReader;</span><br><span class="line"></span><br><span class="line">import service.ReadData;</span><br><span class="line"></span><br><span class="line">public class ThreadRead extends Thread&#123;</span><br><span class="line">	private ReadData <span class="built_in">read</span>;</span><br><span class="line">	private PipedReader input;</span><br><span class="line">	public ThreadRead(ReadData <span class="built_in">read</span>,PipedReader input) &#123;</span><br><span class="line">		this.read = <span class="built_in">read</span>;</span><br><span class="line">		this.input = input;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">		read.readMethod(input);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Run.java代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package <span class="built_in">test</span>;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PipedInputStream;</span><br><span class="line">import java.io.PipedOutputStream;</span><br><span class="line">import java.io.PipedReader;</span><br><span class="line">import java.io.PipedWriter;</span><br><span class="line"></span><br><span class="line">import exthread.ThreadRead;</span><br><span class="line">import exthread.ThreadWrite;</span><br><span class="line"></span><br><span class="line">import service.ReadData;</span><br><span class="line">import service.WriteData;</span><br><span class="line"></span><br><span class="line">public class Run &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			WriteData write = new WriteData();</span><br><span class="line">			ReadData <span class="built_in">read</span> = new ReadData();</span><br><span class="line">			</span><br><span class="line">			PipedWriter out = new PipedWriter();</span><br><span class="line">			PipedReader input = new PipedReader();</span><br><span class="line">			out.connect(input);</span><br><span class="line"></span><br><span class="line">			ThreadRead threadRead = new ThreadRead(<span class="built_in">read</span>,input);</span><br><span class="line">			threadRead.start();</span><br><span class="line">			//Thread.sleep(2000);</span><br><span class="line">			ThreadWrite threadWrite = new ThreadWrite(write,out);</span><br><span class="line">			threadWrite.start();</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		&#125;catch(Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下:<br><img src="/images/pipedstreamchar.PNG" alt=""><br>这个实验是在两个线程间通过管道流进行字符数据的传输。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[通过管道进行线程间的通信：字节流]]></title>
      <url>http://yoursite.com/2016/04/25/%E9%80%9A%E8%BF%87%E7%AE%A1%E9%81%93%E8%BF%9B%E8%A1%8C%E7%BA%BF%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%EF%BC%9A%E5%AD%97%E8%8A%82%E6%B5%81/</url>
      <content type="html"><![CDATA[<p>在java语言中提供了各种各样的输入和输出流Stream，使我们能够方便的对数据进行操作，其中管道流（pipeStream）是一种特殊流，用于在不同的线程间直接传送数据。一个线程发送数据到输出管道，另一个线程输出管道中获取数据，中间介质是内存。实现不同线程之间的通信，而无需借助中间临时文件。<br><a id="more"></a><br>在java的jdk中提供了四种类来实现线程间的通信：<br>1） PipedInputStream和PipedOutputSteam : 这两个类操纵的是字节流；<br>2） PipedReader 和 PipedWriter： 这两个类操作的是字符流；<br>下边我们看下字节流通信实例：<br>WriteData.java代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package service;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PipedOutputStream;</span><br><span class="line"></span><br><span class="line">public class WriteData &#123;</span><br><span class="line">	public void writeMethod(PipedOutputStream out) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			System.out.println(<span class="string">"write:"</span>);</span><br><span class="line">			<span class="keyword">for</span>(int i = 0 ;i &lt; 3000; i ++) &#123;</span><br><span class="line">				String outData = <span class="string">""</span> + (i + 1);</span><br><span class="line">				out.write(outData.getBytes());//往输出管道输出数据，所以用PipedOutputStream</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">			out.close();</span><br><span class="line">		&#125;catch(IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ReadData.java代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package service;</span><br><span class="line"></span><br><span class="line">import java.io.PipedInputStream;</span><br><span class="line"></span><br><span class="line">public class ReadData &#123;</span><br><span class="line">	public void <span class="built_in">read</span>Method(PipedInputStream input) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			System.out.println(<span class="string">"read:"</span>);</span><br><span class="line">			byte[] byteArray = new byte[20];</span><br><span class="line">			byteArray[0] = 1;</span><br><span class="line">			int <span class="built_in">read</span>Length = input.read(byteArray);//从管道流中读取数据，如果管道流中没有数据，那么这个方法阻塞</span><br><span class="line">			<span class="keyword">while</span>(<span class="built_in">read</span>Length != -1) &#123;</span><br><span class="line">				String newData = new String(byteArray, 0, <span class="built_in">read</span>Length);</span><br><span class="line">				System.out.println(newData);</span><br><span class="line">				<span class="built_in">read</span>Length = input.read(byteArray);</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println();</span><br><span class="line">			input.close();</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ThreadWrite.java代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package exthread;</span><br><span class="line"></span><br><span class="line">import java.io.PipedOutputStream;</span><br><span class="line"></span><br><span class="line">import service.WriteData;</span><br><span class="line"></span><br><span class="line">public final class ThreadWrite extends Thread&#123;</span><br><span class="line">	private WriteData write;</span><br><span class="line">	private PipedOutputStream out;</span><br><span class="line">	public ThreadWrite(WriteData write, PipedOutputStream out) &#123;</span><br><span class="line">		this.write = write;</span><br><span class="line">		this.out = out;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">		write.writeMethod(out);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ThreadRead.java代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package exthread;</span><br><span class="line"></span><br><span class="line">import java.io.PipedInputStream;</span><br><span class="line"></span><br><span class="line">import service.ReadData;</span><br><span class="line"></span><br><span class="line">public class ThreadRead extends Thread&#123;</span><br><span class="line">	private ReadData <span class="built_in">read</span>;</span><br><span class="line">	private PipedInputStream input;</span><br><span class="line">	public ThreadRead(ReadData <span class="built_in">read</span>,PipedInputStream input) &#123;</span><br><span class="line">		this.read = <span class="built_in">read</span>;</span><br><span class="line">		this.input = input;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">		read.readMethod(input);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Run.java代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package <span class="built_in">test</span>;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.PipedInputStream;</span><br><span class="line">import java.io.PipedOutputStream;</span><br><span class="line"></span><br><span class="line">import exthread.ThreadRead;</span><br><span class="line">import exthread.ThreadWrite;</span><br><span class="line"></span><br><span class="line">import service.ReadData;</span><br><span class="line">import service.WriteData;</span><br><span class="line"></span><br><span class="line">public class Run &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			WriteData write = new WriteData();</span><br><span class="line">			ReadData <span class="built_in">read</span> = new ReadData();</span><br><span class="line">			</span><br><span class="line">			PipedOutputStream out = new PipedOutputStream();</span><br><span class="line">			PipedInputStream input = new PipedInputStream();</span><br><span class="line">			out.connect(input);</span><br><span class="line"></span><br><span class="line">			ThreadRead threadRead = new ThreadRead(<span class="built_in">read</span>,input);</span><br><span class="line">			threadRead.start();</span><br><span class="line">			//Thread.sleep(2000);</span><br><span class="line">			ThreadWrite threadWrite = new ThreadWrite(write,out);</span><br><span class="line">			threadWrite.start();</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">			</span><br><span class="line">		&#125;catch(Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下：<br><img src="/images/pipedstreambybyte.PNG" alt=""><br>注意：使用代码inputStream.connect(outputStream)或者outPutStream.connect(inputStream)的作用使两个Stream之间产生通信连接，这样才可以将数据写入写出。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[线程中suspend和yield方法的区别]]></title>
      <url>http://yoursite.com/2016/04/23/%E7%BA%BF%E7%A8%8B%E4%B8%ADsuspend%E5%92%8Cyield%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<p>suspend方法调用后，线程放弃cpu，但是一直持有其他的资源，知道resume将程序重新启动，这时候会再次获得cup。<br>而yield方法调用后，线程放弃cpu，但放弃多长时间不一定，有可能刚刚放弃cpu，就马上又获得了cpu了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[线程的暂停总结]]></title>
      <url>http://yoursite.com/2016/04/23/%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%9A%82%E5%81%9C/</url>
      <content type="html"><![CDATA[<p>暂停线程意味着此线程还可以恢复执行。在java多线程中，可以使用suspend()方法暂停线程，使用resume()方法恢复线程的执行。<br><a id="more"></a></p>
<p>1 suspend()方法使用：<br>thread.suspend();<br>resume()方法使用：<br>thread.resume();<br>2 suspend与resume的方法的缺点：<br>    2.1 独占<br>        在使用suspend和resume方法时候，如果使用不当，极易造成公共的同步对象的独占，使得其他线程无法正常访问文公同步对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package exthread;</span><br><span class="line"></span><br><span class="line">public class SynchronizedObject &#123;</span><br><span class="line">	synchronized public void <span class="function"><span class="title">printString</span></span>() &#123;</span><br><span class="line">		System.out.println(<span class="string">"begin"</span>);</span><br><span class="line">		<span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">"a"</span>) )&#123;</span><br><span class="line">			System.out.println(<span class="string">"a 线程被永远的 suspend 了！"</span>);</span><br><span class="line">			Thread.currentThread().suspend();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"end"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<pre><code>文件Run.java代码如下：
</code></pre><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package exthread;</span><br><span class="line"></span><br><span class="line">public class Run &#123;</span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		final SynchronizedObject object = new SynchronizedObject();</span><br><span class="line">		Thread thread1 = new <span class="function"><span class="title">Thread</span></span>() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">				object.printString();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		thread1.setName(<span class="string">"a"</span>);</span><br><span class="line">		thread1.start();</span><br><span class="line">		Thread.sleep(1000);</span><br><span class="line">		Thread thread2 = new <span class="function"><span class="title">Thread</span></span>() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">				System.out.println(<span class="string">"thread2启动了，但是进入不到printString方法，只打印一个begin"</span>);</span><br><span class="line">				System.out.println(<span class="string">"因为printString方法被线程a锁定了，并且永远的suspend了"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		thread2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下所示：</p>
<p><img src="/images/suspendforsynchronized.PNG" alt=""><br>        另外有一种独占所的情况也要注意，稍有不慎，就会出现意想不到的错误；请看下边的println()源码：<br>        public void println(long x) {<br>            synchronized(this) {<br>                println(x);<br>                newLine();<br>            }<br>        }<br>        我们可以看到这里有一个同步的代码块。在这个代码块里边，所以在线程执行println方法的时候，我们不要suspend线程，否则，该方法其他的线程将不能使用。<br>    2.2 易导致数据的不同步<br>        在使用suspend和resume容易出现因为线程的暂停，而导致数据不同步的情况。<br>        我们看下边的代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package exthread;</span><br><span class="line"></span><br><span class="line">public class MyObject &#123;</span><br><span class="line">	private String username = <span class="string">"1"</span>;</span><br><span class="line">	private String password = <span class="string">"11"</span>;</span><br><span class="line">	public void <span class="built_in">set</span>Value(String u, String p) &#123;</span><br><span class="line">		this.username = u;</span><br><span class="line">		<span class="keyword">if</span>(Thread.currentThread().getName().equals(<span class="string">"a"</span>)) &#123;</span><br><span class="line">			System.out.println(<span class="string">"停止a线程"</span>);</span><br><span class="line">			Thread.currentThread().suspend();</span><br><span class="line">		&#125;</span><br><span class="line">		this.password = p;</span><br><span class="line">	&#125;</span><br><span class="line">	public void <span class="function"><span class="title">printUsernamePassword</span></span>() &#123;</span><br><span class="line">		System.out.println(username + <span class="string">" "</span> + password);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Run.java 文件代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package exthread;</span><br><span class="line"></span><br><span class="line">public class Run &#123;</span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		final MyObject myobject  = new MyObject();</span><br><span class="line">		Thread thread1 = new <span class="function"><span class="title">Thread</span></span>() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">				myobject.setValue(<span class="string">"a"</span>, <span class="string">"aa"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		thread1.setName(<span class="string">"a"</span>);</span><br><span class="line">		thread1.start();</span><br><span class="line">		thread1.sleep(500);</span><br><span class="line">		Thread thread2  = new <span class="function"><span class="title">Thread</span></span>() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">				myobject.printUsernamePassword();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		thread2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序运行结果如下：</p>
<p><img src="/images/Datainconsistency.PNG" alt=""><br>所以在程序中只用suspend要格外的小心。关于如何解决此类问题，请持续关注本博客。欢迎大家在本博客下边评论指正。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[线程停止]]></title>
      <url>http://yoursite.com/2016/04/22/%E7%BA%BF%E7%A8%8B%E5%81%9C%E6%AD%A2/</url>
      <content type="html"><![CDATA[<p>在前边的博客中，曾经介绍了线程是怎么创建和开启的。今天我来分享下我自己对线程是怎么关闭的一些理解。</p>
<p>停止线程不像java语言中的break语句那样那么干脆，需要一些技巧性的处理。</p>
<p>在java中有以下三种方式可以停止正在执行的线程。：<br>1）使用退标志，使线程正常退出，也就是完成run方法后终止线程。<br>2）使用stop方法强制终止线程。但是这个方法不被推荐。因为stop是不安全的。和suspend以及resume一样，都已经被废弃。使用过期的方法，可能要产生不可预料的结果。<br>3）使用interrupt方法中断线程。</p>
<p>在大多数停止的线程的操作使用的是Thread.interrupt()方法。但是这个方法不会终止正在执行的线程。需要加入一个判断才可以完成线程的停止。</p>
<a id="more"></a>
<p>一 在详细介绍线程停止的知识点之前，我们先来看下如何判断线程的状态是不是停止的。在java的SDK中，Thread.java类提供了两种方法。<br>1）this.interrupted() 测试当前线程是否已经中断。线程的中断状态由该方法清除。<br>2）this.isInterrupted(): 测试当前进程是否已经被中断。不清除中断状态。</p>
<p>二：线程停止的具体操作</p>
<p>2.1有了前边的知识点，就可以在线程中使用for语句来判断一下线程是否是停止状态。如果是停止状态的话，则后边的代码就不在执行即可。<br>例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">		super.run();</span><br><span class="line">		<span class="keyword">for</span>(int i = 0; i &lt; 5000; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(this.interrupted()) &#123;</span><br><span class="line">				System.out.println(<span class="string">"已经是停止状态了，我要退出了"</span>);</span><br><span class="line">				<span class="built_in">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"i="</span> + (i+1));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">但是我语句，我们仔细思考就会知道，在上边的示例虽然停止了进程，但是如果<span class="keyword">for</span>语句下边还有语句，那么这些语句还是会执行。那么我们应该如何解决这类问题呢？请往下看。</span><br><span class="line"></span><br><span class="line">2.2 我们如何解决2.1中的问题呢？</span><br><span class="line">请看下边的代码：</span><br><span class="line">```bash </span><br><span class="line">package exthread;</span><br><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">		super.run();</span><br><span class="line">		<span class="function"><span class="title">try</span></span>() &#123;</span><br><span class="line">			<span class="keyword">for</span>(int i = 0 ; i &lt;5000; i ++) &#123;</span><br><span class="line">				<span class="function"><span class="title">if</span></span>() &#123;</span><br><span class="line">					System.out.println(<span class="string">"已经是停止状态了，我要退出了"</span>);</span><br><span class="line">					throw new InterruptedException();</span><br><span class="line">				&#125;</span><br><span class="line">				Sysout.out.println(<span class="string">"i="</span>+ (i+1));</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"我在for下边"</span>);</span><br><span class="line">		&#125;catch(InterruptedException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"进入到MyThread类的run方法的catch了"</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样的话，for下边的语句就不在执行了。<br>上边的操作都是针对正在执行的线程来操作的，那么针对沉睡的线程，停止线程该会出现什么情况呢？请看2.3</p>
<p>2.3 如果线程是沉睡，我们改如何停止线程。<br>请看下边的代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class MyThread extends Thread &#123;</span><br><span class="line">	@Override </span><br><span class="line">	public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">		super.run();</span><br><span class="line">		try &#123;</span><br><span class="line">			System.out.println(<span class="string">"run begin"</span>);</span><br><span class="line">			Thread.sleep(2000);</span><br><span class="line">			System.out.println(run end);</span><br><span class="line">		&#125;catch (InterruptedExxception e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"在沉睡中被停止！进入catch！"</span>+this.isInterrupted());</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>包含main函数的文件Run.java代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Run &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		try&#123;</span><br><span class="line">			MyThread thread = new MyThread();</span><br><span class="line">			thread.start();</span><br><span class="line">			Thread.sleep(200);</span><br><span class="line">			thread.interrupted();</span><br><span class="line">		&#125;	catch(InterruptedException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"main catch"</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"end!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序运行的结果是：<br>run begin<br>end!<br>在沉睡中被停止！进入catch！false<br>java.lang.InterruptedException:sleep interrupted<br>….<br>另外我们还可以做这样的实验：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package exthread;</span><br><span class="line"></span><br><span class="line">public class MyThread extends Thread&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">		super.run();</span><br><span class="line">		try&#123;</span><br><span class="line">			<span class="keyword">for</span>(int i =0 ;i &lt; 100000; i ++) &#123;</span><br><span class="line">				System.out.println(<span class="string">"i = "</span> + (i+1));</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"run begin"</span>);</span><br><span class="line">			Thread.sleep(200000);</span><br><span class="line">			System.out.println(<span class="string">"run end"</span>);</span><br><span class="line">		&#125;catch (InterruptedException e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"先停止，在遇到sleep!进入到catch！"</span>);</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Run.java文件内容为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package exthread;</span><br><span class="line"></span><br><span class="line">public class Run &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		MyThread thread  = new MyThread();</span><br><span class="line">		thread.start();</span><br><span class="line">		thread.interrupt();</span><br><span class="line">		System.out.println(<span class="string">"end"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行的结果是，如下图：<br><img src="/images/sleepandinterrupted.png" alt=""><br>综上，在interrupte和sleep互操作的时候，无论谁前谁后，都会跑出InterruptedException，然后进入到catch代码块。</p>
<p>2.4 暴力停止线程</p>
<p>使用stop()方法停止线程是是非常暴力的。<br>调用stop（）方法会抛出java.lang.ThreadDeath异常，但是在通常情况下，此异常不需要显示的捕获。<br>方法stop()已经被背弃了，因为如果强制使线程停止则可能使一些清理性的工作得不到完成。另外的一个情况就是对锁的对象进行了不合时宜的“解锁”，然后就会导致数据的不一致。</p>
<p>2.5 使用return停止线程</p>
<p>将方法interrupt() 和return结合使用也能实现线程的停止的效果。</p>
<p>看下边的例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package exthread;</span><br><span class="line"></span><br><span class="line">public class MyThread extends Thread&#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(this.isInterrupted()) &#123;</span><br><span class="line">				System.out.println(<span class="string">"被停止了！"</span>);</span><br><span class="line">				<span class="built_in">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"timer = "</span> + System.currentTimeMillis());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Run.java 代码为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package exthread;</span><br><span class="line"></span><br><span class="line">public class Run &#123;</span><br><span class="line">	public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">		MyThread thread  = new MyThread();</span><br><span class="line">		thread.start();</span><br><span class="line">		Thread.sleep(2000);</span><br><span class="line">		thread.interrupt();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果是:<br><img src="/images/interruptandreturn.png" alt=""><br>可以看出线程被终止了。</p>
<p>不过还是建议使用”抛异常”的方法来实现线程的停止，因为在catch块中还能将异常向上抛，使线程停止的事件得以传播。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[非递归方式实现斐波那契数列]]></title>
      <url>http://yoursite.com/2016/04/19/%E9%9D%9E%E9%80%92%E5%BD%92%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
      <content type="html"><![CDATA[<p>今天做的是一道关于斐波那契数列的题目，本来在牛客网上准备用递归实现，但是递归的时间到达不到牛客网的要求，所以改用非递归的方式；<br><a id="more"></a></p>
<p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项；</p>
<p>斐波那契数列的介绍</p>
<p>斐波那契数列，又称黄金分割数列，指的是这样一个数列：0、1、1、2、3、5、8、13、21、34、……在数学上，斐波纳契数列以如下被以递归的方法定义：F（0）=0，F（1）=1，F（n）=F(n-1)+F(n-2)（n≥2，n∈N*）；</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int Fibonacci(int n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == 0 ) &#123;</span><br><span class="line">            <span class="built_in">return</span> 0;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == 1) &#123;</span><br><span class="line">            <span class="built_in">return</span> 1;</span><br><span class="line">        &#125;</span><br><span class="line">				int a = 0;</span><br><span class="line">        int b = 1; </span><br><span class="line">        int c = 1;</span><br><span class="line">        <span class="keyword">for</span> (int i = 1; i &lt; n; i ++) &#123;</span><br><span class="line">            c = a + b ;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我做题的思想： 设置两个游标a,b,分别记录x-1项的值和x-2的值，然后设置游标c的值为前两项之和。每进行一次计算，游标a,b都要向后移动一个位置。这个直到游标c移动到n位置。则计算结束。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[二维数组的查找]]></title>
      <url>http://yoursite.com/2016/04/16/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      <content type="html"><![CDATA[<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<p>这是一道来自牛客网的一道编程题，有人写了下边的代码：<br><a id="more"></a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean Find(int [][] array,int target) &#123;</span><br><span class="line">		int m = array.length - 1;</span><br><span class="line">        int i = 0;</span><br><span class="line">        <span class="keyword">while</span>(m &gt;= 0 &amp;&amp; i &lt; array[0].length)&#123;</span><br><span class="line">            <span class="keyword">if</span>(array[m][i] &gt; target)</span><br><span class="line">                m--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[m][i] &lt; target)</span><br><span class="line">                i++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>算法分析：<br>解法一：对于这样一个二维数组，我们可以直接用暴力解决：用两重循环重头开始遍历。（代码比较简单，这里省略，以后有时间补上）（时间复杂度是O(n^2）)。</p>
<p>解法二：由于每行都是有序的数组，这个时候我们也比较容易想到二分查找。我们可以对每行进行二分查找（时间复杂度是O(n*log2(底数)n)）。</p>
<p>解法三；即上边的算法。这个时候的时间为（O（n））（1^2 + 2^2 + 3^2 + 4^2 + … n^2 +(n+1)(n-1)+(n+2)(n-2)+(n+3)(n-3)+…+(n+n-1)(n-(n-1))）/n^2</p>
<p>综上解法三最省时间，是最优算法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[算法世界]]></title>
      <url>http://yoursite.com/2016/04/14/%E7%AE%97%E6%B3%95%E4%B8%96%E7%95%8C/</url>
      <content type="html"><![CDATA[<p>好久没有写算法的程序的，感觉脑袋都有生锈了。考虑到算法对自己的思维有很大的帮助，而且对代码的要优化，对编写出高效的程序都是必不可少。因此必须要懂算法。算法如此重要，我决定要重新拾起算法了。</p>
<p>从今天起，我要尽力每天完成一两个算法。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java主函数所在类的思考]]></title>
      <url>http://yoursite.com/2016/04/11/java%E4%B8%BB%E5%87%BD%E6%95%B0%E6%89%80%E5%9C%A8%E7%B1%BB%E7%9A%84%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<p>今天跟同学突然聊到关于java的main函数所在类的实例化问题；他突然问我，在程序运行时候，main函数所在的类是否会实例化，我还真一时脑袋没转过来，不过，还来想想，这个问题还是挺简单的。</p>
<p>main函数所在类是否实例化，还是看你是否用法哦了该类的实例，是否写了new方法。</p>
<p>其实，main所在的类和其他类没有什么区别，只是main函数式程序的入口。在程序启动时候，调用main函数。因为main函数是static的，所以，其所在的类及时不实例化，他也可以运行。当你用到该类的实例的时候，你会new出一个实例，这时候main函数所在类就实例化了。如果你没有用到该类的实例，那么你就不需要new出这么个实例，所以，这个时候就没有实例化main函数所在的类。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MySql外键设置中的Cascade, no action,restrict ,set null(分享)]]></title>
      <url>http://yoursite.com/2016/04/01/MySql%E5%A4%96%E9%94%AE%E8%AE%BE%E7%BD%AE%E4%B8%AD%E7%9A%84Cascade-no-action-restrict-set-null-%E5%88%86%E4%BA%AB/</url>
      <content type="html"><![CDATA[<p>今天项目的需要，需要MySql数据库表中添加一些外键约束，本人由于对数据库的外键长时间不使用，已经全部归还给了老师，这次通过查找资料，也终于回想起来了，在这了分享给大家<br>本文对cascade, no action, restrict,set null进行了回顾。<br><a id="more"></a><br>cascade 方式：<br> 在父表上做更新或者删除的时候，同步更新或者删除子表的匹配记录；</p>
<p> no action方式<br> 如果子表中有匹配记录，那么则不允许对父表对应的候选键进行更新删除。</p>
<p> restrict 方式<br> 同 no action,都是直接检查外键约束，如果有外键约束的话，就拒绝父表进行相应的更新删除。</p>
<p>set null方式<br> 在父表上更新或者删除记录的时候，将子表上匹配记录的列设置为null；这里设计表的时候要注意，子表的外键列不能为null;</p>
<p> 还有一种是set default 方式</p>
<p> 父表有更新的时候，子表将外键类设置为一个默认的值。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java对象池技术的原理及其实现(转载)]]></title>
      <url>http://yoursite.com/2016/03/30/Java%E5%AF%B9%E8%B1%A1%E6%B1%A0%E6%8A%80%E6%9C%AF%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0-%E8%BD%AC%E8%BD%BD/</url>
      <content type="html"><![CDATA[<p>今天给大家分享下Java对象池技术的一些知识：</p>
<p>本文在分析对象池技术基本原理的基础上，给出了对象池技术的两种实现方式。还指出了使用对象池技术时所应注意的问题。<br>Java对象的生命周期分析<br><a id="more"></a><br>　　Java对象的生命周期大致包括三个阶段：对象的创建，对象的使用，对象的清除。因此，对象的生命周期长度可用如下的表达式表示：T = T1 + T2 +T3。其中T1表示对象的创建时间，T2表示对象的使用时间，而T3则表示其清除时间。由此，我们可以看出，只有T2是真正有效的时间，而T1、T3则是对象本身的开销。下面再看看T1、T3在对象的整个生命周期中所占的比例。</p>
<p>　　我们知道，Java对象是通过构造函数来创建的，在这一过程中，该构造函数链中的所有构造函数也都会被自动调用。另外，默认情况下，调用类的构造函数时，Java会把变量初始化成确定的值：所有的对象被设置成null，整数变量（byte、short、int、long）设置成0，float和double变量设置成0.0，逻辑值设置成false。所以用new关键字来新建一个对象的时间开销是很大的，如表1所示。</p>
<p>表1 一些操作所耗费时间的对照表</p>
<p>运算操作    示例    标准化时间<br>本地赋值    i = n        1.0<br>实例赋值    this.i = n    1.2<br>方法调用    Funct()        5.9<br>新建对象    New Object()    980<br>新建数组    New int[10]    3100</p>
<p>从表1可以看出，新建一个对象需要980个单位的时间，是本地赋值时间的980倍，是方法调用时间的166倍，而若新建一个数组所花费的时间就更多了。</p>
<p>再看清除对象的过程。我们知道，Java语言的一个优势，就是Java程序员勿需再像C/C++程序员那样，显式地释放对象，而由称为垃圾收集器（Garbage Collector）的自动内存管理系统，定时或在内存凸现出不足时，自动回收垃圾对象所占的内存。凡事有利总也有弊，这虽然为Java程序设计者提供了极大的方便，但同时它也带来了较大的性能开销。这种开销包括两方面，首先是对象管理开销，GC为了能够正确释放对象，它必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等。其次，在GC开始回收“垃圾”对象时，系统会暂停应用程序的执行，而独自占用CPU。</p>
<p>　　因此，如果要改善应用程序的性能，一方面应尽量减少创建新对象的次数；同时，还应尽量减少T1、T3的时间，而这些均可以通过对象池技术来实现。</p>
<p>　　对象池技术的基本原理</p>
<p>　　对象池技术基本原理的核心有两点：缓存和共享，即对于那些被频繁使用的对象，在使用完后，不立即将它们释放，而是将它们缓存起来，以供后续的应用程序重复使用，从而减少创建对象和释放对象的次数，进而改善应用程序的性能。事实上，由于对象池技术将对象限制在一定的数量，也有效地减少了应用程序内存上的开销。</p>
<p>　　实现一个对象池，一般会涉及到如下的类：</p>
<p>　　1）对象池工厂（ObjectPoolFactory）类</p>
<p>　　该类主要用于管理相同类型和设置的对象池（ObjectPool），它一般包含如下两个方法：</p>
<p>　　·createPool：用于创建特定类型和设置的对象池；</p>
<p>　　·destroyPool：用于释放指定的对象池；</p>
<p>　　同时为保证ObjectPoolFactory的单一实例，可以采用Singleton设计模式，见下述getInstance方法的实现：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ObjectPoolFactory <span class="function"><span class="title">getInstance</span></span>() &#123;</span><br><span class="line">　<span class="keyword">if</span> (poolFactory == null) &#123;</span><br><span class="line">　　poolFactory = new ObjectPoolFactory();</span><br><span class="line">　&#125;</span><br><span class="line">　<span class="built_in">return</span> poolFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　2）参数对象（ParameterObject）类</p>
<p>　　该类主要用于封装所创建对象池的一些属性参数，如池中可存放对象的数目的最大值（maxCount）、最小值（minCount）等。</p>
<p>　3）对象池（ObjectPool）类</p>
<p>　　用于管理要被池化对象的借出和归还，并通知PoolableObjectFactory完成相应的工作。它一般包含如下两个方法：</p>
<p>　　　·getObject：用于从池中借出对象；<br>　　　·returnObject：将池化对象返回到池中，并通知所有处于等待状态的线程；</p>
<p>　4）池化对象工厂（PoolableObjectFactory）类</p>
<p>　　该类主要负责管理池化对象的生命周期，就简单来说，一般包括对象的创建及销毁。该类同ObjectPoolFactory一样，也可将其实现为单实例。<br>　<br>通用对象池的实现</p>
<p>　　对象池的构造和管理可以按照多种方式实现。最灵活的方式是将池化对象的Class类型在对象池之外指定，即在ObjectPoolFactory类创建对象池时，动态指定该对象池所池化对象的Class类型，其实现代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ObjectPool createPool(ParameterObject paraObj,Class clsType) &#123;</span><br><span class="line">　<span class="built_in">return</span> new ObjectPool(paraObj, clsType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，paraObj参数用于指定对象池的特征属性，clsType参数则指定了该对象池所存放对象的类型。对象池（ObjectPool）创建以后，下面就是利用它来管理对象了，具体实现如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectPool &#123;</span><br><span class="line">　private ParameterObject paraObj;//该对象池的属性参数对象</span><br><span class="line">　private Class clsType;//该对象池中所存放对象的类型</span><br><span class="line">　private int currentNum = 0; //该对象池当前已创建的对象数目</span><br><span class="line">　private Object currentObj;//该对象池当前可以借出的对象</span><br><span class="line">　private Vector pool;//用于存放对象的池</span><br><span class="line">　public ObjectPool(ParameterObject paraObj, Class clsType) &#123;</span><br><span class="line">　　this.paraObj = paraObj;</span><br><span class="line">　　this.clsType = clsType;</span><br><span class="line">　　pool = new Vector();</span><br><span class="line">　&#125;</span><br><span class="line">　public Object <span class="function"><span class="title">getObject</span></span>() &#123;</span><br><span class="line">　　<span class="keyword">if</span> (pool.size() &lt;= paraObj.getM<span class="keyword">in</span>Count()) &#123;</span><br><span class="line">　　　<span class="keyword">if</span> (currentNum &lt;= paraObj.getMaxCount()) &#123;</span><br><span class="line">　　　　//如果当前池中无对象可用，而且已创建的对象数目小于所限制的最大值，就利用</span><br><span class="line">　　　　//PoolObjectFactory创建一个新的对象</span><br><span class="line">　　　　PoolableObjectFactory objFactory =PoolableObjectFactory.getInstance();</span><br><span class="line">　　　　currentObj = objFactory.create Object (clsType);</span><br><span class="line">　　　　currentNum++;</span><br><span class="line">　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　//如果当前池中无对象可用，而且所创建的对象数目已达到所限制的最大值，</span><br><span class="line">　　　　//就只能等待其它线程返回对象到池中</span><br><span class="line">　　　　synchronized (this) &#123;</span><br><span class="line">　　　　　try &#123;</span><br><span class="line">　　　　　　<span class="built_in">wait</span>();</span><br><span class="line">　　　　　&#125; catch (InterruptedException e) &#123;</span><br><span class="line">　　　　　　System.out.println(e.getMessage());</span><br><span class="line">　　　　　　e.printStackTrace();</span><br><span class="line">　　　　　&#125;</span><br><span class="line">　　　　　currentObj = pool.firstElement();</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　&#125;</span><br><span class="line">　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　//如果当前池中有可用的对象，就直接从池中取出对象</span><br><span class="line">　　　currentObj = pool.firstElement();</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="built_in">return</span> currentObj;</span><br><span class="line">&#125;</span><br><span class="line">　　public void <span class="built_in">return</span>Object(Object obj) &#123;</span><br><span class="line">　　　// 确保对象具有正确的类型</span><br><span class="line">　　　<span class="keyword">if</span> (obj.isInstance(clsType)) &#123;</span><br><span class="line">　　　　pool.addElement(obj);</span><br><span class="line">　　　　synchronized (this) &#123;</span><br><span class="line">　　　　　notifyAll();</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　throw new IllegalArgumentException(<span class="string">"该对象池不能存放指定的对象类型"</span>);</span><br><span class="line">　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line">```bash</span><br><span class="line">　从上述代码可以看出，ObjectPool利用一个java.util.Vector作为可扩展的对象池，并通过它的构造函数来指定池化对象的Class类型及对象池的一些属性。在有对象返回到对象池时，它将检查对象的类型是否正确。当对象池里不再有可用对象时，它或者等待已被使用的池化对象返回池中，或者创建一个新的对象实例。不过，新对象实例的创建并不在ObjectPool类中，而是由PoolableObjectFactory类的createObject方法来完成的，具体实现如下：</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">public Object createObject(Class clsType) &#123;</span><br><span class="line">　Object obj = null;</span><br><span class="line">　try &#123;</span><br><span class="line">　　obj = clsType.newInstance();</span><br><span class="line">　&#125; catch (Exception e) &#123;</span><br><span class="line">　　e.printStackTrace();</span><br><span class="line">　&#125; </span><br><span class="line">　<span class="built_in">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　这样，通用对象池的实现就算完成了，下面再看看客户端（Client）如何来使用它，假定池化对象的Class类型为StringBuffer：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//创建对象池工厂</span><br><span class="line">ObjectPoolFactory poolFactory = ObjectPoolFactory. getInstance ();</span><br><span class="line">//定义所创建对象池的属性</span><br><span class="line">ParameterObject paraObj = new ParameterObject(2,1);</span><br><span class="line">//利用对象池工厂,创建一个存放StringBuffer类型对象的对象池</span><br><span class="line">ObjectPool pool = poolFactory.createPool(paraObj,String Buffer.class);</span><br><span class="line">//从池中取出一个StringBuffer对象</span><br><span class="line">StringBuffer buffer = (StringBuffer)pool.getObject();</span><br><span class="line">//使用从池中取出的StringBuffer对象</span><br><span class="line">buffer.append(<span class="string">"hello"</span>);</span><br><span class="line">System.out.println(buffer.toString());</span><br></pre></td></tr></table></figure></p>
<p>　可以看出，通用对象池使用起来还是很方便的，不仅可以方便地避免频繁创建对象的开销，而且通用程度高。但遗憾的是，由于需要使用大量的类型定型（cast）操作，再加上一些对Vector类的同步操作，使得它在某些情况下对性能的改进非常有限，尤其对那些创建周期比较短的对象。</p>
<p>专用对象池的实现　　　　　</p>
<p>　　由于通用对象池的管理开销比较大，某种程度上抵消了重用对象所带来的大部分优势。为解决该问题，可以采用专用对象池的方法。即对象池所池化对象的Class类型不是动态指定的，而是预先就已指定。这样，它在实现上也会较通用对象池简单些，可以不要ObjectPoolFactory和PoolableObjectFactory类，而将它们的功能直接融合到ObjectPool类，具体如下（假定被池化对象的Class类型仍为StringBuffer，而用省略号表示的地方，表示代码同通用对象池的实现）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectPool &#123;</span><br><span class="line">　private ParameterObject paraObj;//该对象池的属性参数对象</span><br><span class="line">　private int currentNum = 0; //该对象池当前已创建的对象数目</span><br><span class="line">　private StringBuffer currentObj;//该对象池当前可以借出的对象</span><br><span class="line">　private Vector pool;//用于存放对象的池</span><br><span class="line">　public ObjectPool(ParameterObject paraObj) &#123;</span><br><span class="line">　　this.paraObj = paraObj;</span><br><span class="line">　　pool = new Vector();</span><br><span class="line">　&#125;</span><br><span class="line">　public StringBuffer <span class="function"><span class="title">getObject</span></span>() &#123;</span><br><span class="line">　　<span class="keyword">if</span> (pool.size() &lt;= paraObj.getM<span class="keyword">in</span>Count()) &#123;</span><br><span class="line">　　　<span class="keyword">if</span> (currentNum &lt;= paraObj.getMaxCount()) &#123;</span><br><span class="line">　　　　currentObj = new StringBuffer();</span><br><span class="line">　　　　currentNum++;</span><br><span class="line">　　　&#125; </span><br><span class="line">　　　. . . </span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="built_in">return</span> currentObj;</span><br><span class="line">　&#125;</span><br><span class="line">　public void <span class="built_in">return</span>Object(Object obj) &#123;</span><br><span class="line">　　// 确保对象具有正确的类型</span><br><span class="line">　　<span class="keyword">if</span> (StringBuffer.isInstance(obj)) &#123;</span><br><span class="line">　　　. . . </span><br><span class="line">　　&#125;</span><br><span class="line">　&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结</p>
<p>　　恰当地使用对象池技术，能有效地改善应用程序的性能。目前，对象池技术已得到广泛的应用，如对于网络和数据库连接这类重量级的对象，一般都会采用对象池技术。但在使用对象池技术时也要注意如下问题： </p>
<p>　　并非任何情况下都适合采用对象池技术。基本上，只在重复生成某种对象的操作成为影响性能的关键因素的时候，才适合采用对象池技术。而如果进行池化所能带来的性能提高并不重要的话，还是不采用对象池化技术为佳，以保持代码的简明。</p>
<p>　　要根据具体情况正确选择对象池的实现方式。如果是创建一个公用的对象池技术实现包，或需要在程序中动态指定所池化对象的Class类型时，才选择通用对象池。而大部分情况下，采用专用对象池就可以了。</p>
<p>转自:<a href="http://dev.yesky.com/421/2685421.shtml" target="_blank" rel="external">http://dev.yesky.com/421/2685421.shtml</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[spring-aop相关术语]]></title>
      <url>http://yoursite.com/2016/03/27/spring-aop%E7%9B%B8%E5%85%B3%E6%9C%AF%E8%AF%AD/</url>
      <content type="html"><![CDATA[<p>aop是采取的横向抽取的机制，取代了传统的取代了传统的纵向继承体系。<br>由于继承，会产生很多的侵入式代码复用，所以我们使用了横向的抽取机制（aop方式），这就是所谓的不需要修改原来的代码，只是通过代理对原来的功能进行增强。这种机制运用的就是代理。</p>
<p>JointPoint:连接点。指所有被拦截到的点。因为代理对象会对被代理目标对象的所有方法进行拦截，所以，被代理对象的所有方法都是连接点。</p>
<p>PointCut ：切入点，只spring配置中，指明对那几个方法起拦截作用，这几个点就是切入点。</p>
<p>Advice ： 通知、也叫作增强，指对目标方法的增强代码。</p>
<p>Intruction： 引介，这是一种特殊的Advice，但是引介不是对方法的增强，而是对类的增强，比如对某一个类增加属性或者方法。</p>
<p>Target：目标对象，指被拦截的对象。</p>
<p>Weaving：织入，指的是将advice 应用到 target的过程。</p>
<p>Aspect：切面，是切点和通知的结合。通常一个切面可以包含多个切点和多个通知。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[主副线程的交替运行(多线程编程)]]></title>
      <url>http://yoursite.com/2016/03/24/%E4%B8%BB%E5%89%AF%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>实现下列需求：<br>子线程循环10次，接着主线程循环100次，接着又回到子线程循环10次，接着又回到主线程循环100次，如此循环100次。<br><a id="more"></a></p>
<p>代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package cn.cqupt.check;</span><br><span class="line"></span><br><span class="line">public class TestThread2 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new TestThread2().init();</span><br><span class="line">	&#125;</span><br><span class="line">	public void <span class="function"><span class="title">init</span></span>() &#123;</span><br><span class="line">		final Business business = new Business();</span><br><span class="line">		new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</span><br><span class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">				<span class="keyword">for</span>(int i =0;i &lt; 50 ; i++) &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						business.subThread(i);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						// TODO Auto-generated catch block</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		<span class="keyword">for</span>(int i = 0; i&lt;50; i ++) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				business.mainThread(i);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				// TODO Auto-generated catch block</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	private class Business &#123;</span><br><span class="line">		boolean bShouldSub = <span class="literal">true</span>;</span><br><span class="line">		public synchronized void mainThread(int i) throws InterruptedException &#123;</span><br><span class="line">			<span class="keyword">if</span>(bShouldSub) &#123;</span><br><span class="line">				this.wait();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(int j = 0; j &lt; 100;j++ ) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">"i="</span> + i+<span class="string">", j="</span> +j);</span><br><span class="line">			&#125;</span><br><span class="line">			bShouldSub = <span class="literal">true</span>;</span><br><span class="line">			this.notify();</span><br><span class="line">		&#125;</span><br><span class="line">		public synchronized void subThread(int i) throws InterruptedException &#123;</span><br><span class="line">			<span class="keyword">if</span>(!bShouldSub) &#123;</span><br><span class="line">				this.wait();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(int j = 0; j &lt; 10;j++ ) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">"i="</span> + i+<span class="string">", j="</span> +j);</span><br><span class="line">			&#125;</span><br><span class="line">			bShouldSub = <span class="literal">false</span>;</span><br><span class="line">			this.notify();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[多线程的几种方法？同步的几种方法？]]></title>
      <url>http://yoursite.com/2016/03/24/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9F%E5%90%8C%E6%AD%A5%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>多线程的实现的三种方法；<br><a id="more"></a><br>1 实现Runnable接口<br>代码如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</span><br><span class="line">	public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">		//填入线程要执行的代码</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></p>
<p>2 继承Thread对象，重写里边的Runnable方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">		//填入线程要执行的方法</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">new Myhread().start();//启动线程</span><br></pre></td></tr></table></figure></p>
<p>3 实现Callable接口，并用FutureTask 包装器封装成task兑现，交给Thread执行即可:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.current.*;</span><br><span class="line">class MyCounter implements Callable&lt;Integer&gt; &#123;</span><br><span class="line">	//重写call方法</span><br><span class="line">	public Integer <span class="function"><span class="title">call</span></span>() &#123;</span><br><span class="line">		//填入线程要执行的方法</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//实现该类</span><br><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		MyCounter mc = new MyCounter();</span><br><span class="line">		FutureTask&lt;Integer&gt; task  = new FutureTask&lt;Integer&gt;(mc);//封装成task任务</span><br><span class="line">		Thread  t = new Thread(task);</span><br><span class="line">		t.start();//启动线程</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同步的几种方法：<br>同步的实现方法有两种：分别是synchronized，wait与notify<br>wait():使一个线程处于等待状态，并释放所有的锁<br>sleep():使一个正在运行的线程处于休眠状态，是Thread的静态方法，调用该方法要捕捉InterruptedException（中断异常）异常，调用该方法进入休眠状态的线程，不需要使用notify或者notifyAll方法唤醒，并且notify或者notifyAll方法也不能唤醒此类线程。<br>notify():唤醒一个处于等待状态的线程，注意是在调用该方法的时候，并不能确定唤醒的是哪一个线程，而是由JVM确定唤醒的是哪个线程，而且不是按照优先级。<br>notifyAll():唤醒所有的等待线程，注意不是给所有的线程一个锁，而是让他们竞争锁。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java8特性介绍(转载)]]></title>
      <url>http://yoursite.com/2016/03/23/java8%E7%89%B9%E6%80%A7%E4%BB%8B%E7%BB%8D(%E8%BD%AC%E8%BD%BD)/</url>
      <content type="html"><![CDATA[<p>这次博客推荐的java8的十大新特性，并将使用简单的代码示例来指你如何使用默认接口方法。比如流，函数式接口，Map以及全新的日期API</p>
<p>本教程将用带注释的简单代码来描述新特性，你将看不到大片吓人的文字。<br><a id="more"></a><br>一 接口额默认方法</p>
<p>java8 允许我们给接口添加一个非抽象的方法实现，只需要使用default关键字即可，这个特性又叫做扩展方法，代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Formula &#123;</span><br><span class="line">	double calculate(int a );</span><br><span class="line">	default double sqrt(int a) &#123;</span><br><span class="line">		retuen Math.squrt(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。<br>代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Formaula formula = new <span class="function"><span class="title">Formula</span></span>() &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public double caculate(int a) &#123;</span><br><span class="line">		<span class="built_in">return</span> squart(a * 100);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;；</span><br><span class="line">formula.caculate(100);//100.0</span><br><span class="line">formula.sqrt(16);//4.0</span><br></pre></td></tr></table></figure></p>
<p>文中的formula被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算 sqrt(a * 100)。在下一节中，我们将会看到实现单方法接口的更简单的做法。</p>
<p>译者注： 在Java中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现，在C++中支持多继承，允许一个子类同时具有多个父类的接口与功能，在其他语言中，让一个类同时具有其他的可复用代码的方法叫做mixin。新的Java 8 的这个特新在编译器实现的角度上来说更加接近Scala的trait。 在C#中也有名为扩展方法的概念，允许给已存在的类型扩展方法，和Java 8的这个在语义上有差别。</p>
<p>二、Lambda 表达式</p>
<p>首先看看在老版本的Java中是如何排列字符串的：<br>代码如下：<br>List<string> names = Arrays.aslist(“peter”,”anna,”mike”,”xenia”);</string></p>
<p>Collections.sort(names,new Comparator<string>() {<br>    @Override<br>    public int compare(String a,String b) {<br>        return b.compareTo(a);<br>    }<br>});<br>只需要给静态方法 Collections.sort 传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。</string></p>
<p>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection.sort(names,(String a, String b) -&gt; <span class="built_in">return</span> b.compareTo(a));</span><br></pre></td></tr></table></figure></p>
<p>看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure></p>
<p>对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure></p>
<p>Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还能作出什么更方便的东西来：</p>
<p>三、函数式接口</p>
<p>Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。</p>
<p>我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 @FunctionalInterface 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface Converter&lt;F, T&gt; &#123;</span><br><span class="line">    T convert(F from);</span><br><span class="line">&#125;</span><br><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(converted);    // 123</span><br></pre></td></tr></table></figure></p>
<p>需要注意如果@FunctionalInterface如果没有指定，上面的代码也是对的。</p>
<p>译者注 将lambda表达式映射到一个单方法的接口上，这种做法在Java 8之前就有别的语言实现，比如Rhino JavaScript解释器，如果一个函数参数接收一个单方法的接口而你传递的是一个function，Rhino 解释器会自动做一个单接口的实例到function的适配器，典型的应用场景有 org.w3c.dom.events.EventTarget 的addEventListener 第二个参数 EventListener。</p>
<p>四、方法与构造函数引用</p>
<p>前一节中的代码还可以通过静态方法引用来表示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</span><br><span class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(converted);   // 123</span><br></pre></td></tr></table></figure></p>
<p>Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">converter = something::startsWith;</span><br><span class="line">String converted = converter.convert(<span class="string">"Java"</span>);</span><br><span class="line">System.out.println(converted);    // <span class="string">"J"</span></span><br></pre></td></tr></table></figure>
<p>接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="title">Person</span></span>() &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    Person(String firstName, String lastName) &#123;</span><br><span class="line">        this.firstName = firstName;</span><br><span class="line">        this.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来我们指定一个用来创建Person对象的对象工厂接口：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface PersonFactory&lt;P extends Person&gt; &#123;</span><br><span class="line">    P create(String firstName, String lastName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PersonFactory&lt;Person&gt; personFactory = Person::new;</span><br><span class="line">Person person = personFactory.create(<span class="string">"Peter"</span>, <span class="string">"Parker"</span>);</span><br></pre></td></tr></table></figure></p>
<p>我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。</p>
<p>五、Lambda 作用域</p>
<p>在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。</p>
<p>六、访问局部变量</p>
<p>我们可以直接在lambda表达式中访问外层的局部变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final int num = 1;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);</span><br><span class="line"> </span><br><span class="line">stringConverter.convert(2);     // 3</span><br></pre></td></tr></table></figure>
<p>但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int num = 1;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line"> </span><br><span class="line">stringConverter.convert(2);     // 3</span><br></pre></td></tr></table></figure></p>
<p>不过这里的num必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int num = 1;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line">num = 3;</span><br></pre></td></tr></table></figure></p>
<p>在lambda表达式中试图修改num同样是不允许的。</p>
<p>七、访问对象字段与静态变量</p>
<p>和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Lambda4 &#123;</span><br><span class="line">    static int outerStaticNum;</span><br><span class="line">    int outerNum;</span><br><span class="line"> </span><br><span class="line">    void <span class="function"><span class="title">testScopes</span></span>() &#123;</span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;</span><br><span class="line">            outerNum = 23;</span><br><span class="line">            <span class="built_in">return</span> String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;</span><br><span class="line">            outerStaticNum = 72;</span><br><span class="line">            <span class="built_in">return</span> String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>八、访问接口的默认方法</p>
<p>还记得第一节中的formula例子么，接口Formula定义了一个默认方法sqrt可以直接被formula的实例包括匿名对象访问到，但是在lambda表达式中这个是不行的。<br>Lambda表达式中是无法访问到默认方法的，以下代码将无法编译：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = (a) -&gt; sqrt( a * 100);</span><br><span class="line">Built-in Functional Interfaces</span><br></pre></td></tr></table></figure></p>
<p>JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。<br>Java 8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。</p>
<p>Predicate接口</p>
<p>Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;</span><br><span class="line"> </span><br><span class="line">predicate.test(<span class="string">"foo"</span>);              // <span class="literal">true</span></span><br><span class="line">predicate.negate().test(<span class="string">"foo"</span>);     // <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</span><br><span class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</span><br><span class="line"> </span><br><span class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</span><br><span class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</span><br></pre></td></tr></table></figure>
<p>Function 接口</p>
<p>Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</span><br><span class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</span><br><span class="line"> </span><br><span class="line">backToString.apply(<span class="string">"123"</span>);     // <span class="string">"123"</span></span><br></pre></td></tr></table></figure>
<p>Supplier 接口</p>
<p>Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = Person::new;</span><br><span class="line">personSupplier.get();   // new Person</span><br></pre></td></tr></table></figure></p>
<p>Consumer 接口</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(<span class="string">"Hello, "</span> + p.firstName);</span><br><span class="line">greeter.accept(new Person(<span class="string">"Luke"</span>, <span class="string">"Skywalker"</span>));</span><br></pre></td></tr></table></figure>
<p>Comparator 接口</p>
<p>Comparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</span><br><span class="line"> </span><br><span class="line">Person p1 = new Person(<span class="string">"John"</span>, <span class="string">"Doe"</span>);</span><br><span class="line">Person p2 = new Person(<span class="string">"Alice"</span>, <span class="string">"Wonderland"</span>);</span><br><span class="line"> </span><br><span class="line">comparator.compare(p1, p2);             // &gt; 0</span><br><span class="line">comparator.reversed().compare(p1, p2);  // &lt; 0</span><br></pre></td></tr></table></figure>
<p>Optional 接口</p>
<p>Optional 不是函数是接口，这是个用来防止NullPointerException异常的辅助类型，这是下一届中将要用到的重要概念，现在先简单的看看这个接口能干什么：</p>
<p>Optional 被定义为一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java 8中，不推荐你返回null而是返回Optional。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">"bam"</span>);</span><br><span class="line"> </span><br><span class="line">optional.isPresent();           // <span class="literal">true</span></span><br><span class="line">optional.get();                 // <span class="string">"bam"</span></span><br><span class="line">optional.orElse(<span class="string">"fallback"</span>);    // <span class="string">"bam"</span></span><br><span class="line"> </span><br><span class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(0)));     // <span class="string">"b"</span></span><br></pre></td></tr></table></figure></p>
<p>Stream 接口</p>
<p>java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如 java.util.Collection的子类，List或者Set， Map不支持。Stream的操作可以串行执行或者并行执行。</p>
<p>首先看看Stream是怎么用，首先创建实例代码的用到的数据List：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();</span><br><span class="line">stringCollection.add(<span class="string">"ddd2"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"aaa2"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"bbb1"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"aaa1"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"bbb3"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"ccc"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"bbb2"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"ddd1"</span>);</span><br></pre></td></tr></table></figure></p>
<p>Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作<br>Filter 过滤</p>
<p>过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(<span class="string">"a"</span>))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"> </span><br><span class="line">// <span class="string">"aaa2"</span>, <span class="string">"aaa1"</span></span><br></pre></td></tr></table></figure>
<p>Sort 排序</p>
<p>排序是一个中间操作，返回的是排序好后的Stream。如果你不指定一个自定义的Comparator则会使用默认排序。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .sorted()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(<span class="string">"a"</span>))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"> </span><br><span class="line">// <span class="string">"aaa1"</span>, <span class="string">"aaa2"</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(stringCollection);</span><br><span class="line">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</span><br></pre></td></tr></table></figure></p>
<p>Map 映射</p>
<p>中间操作map会将元素根据指定的Function接口来依次将元素转成另外的对象，下面的示例展示了将字符串转换为大写字符串。你也可以通过map来讲对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .sorted((a, b) -&gt; b.compareTo(a))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"> </span><br><span class="line">// <span class="string">"DDD2"</span>, <span class="string">"DDD1"</span>, <span class="string">"CCC"</span>, <span class="string">"BBB3"</span>, <span class="string">"BBB2"</span>, <span class="string">"AAA2"</span>, <span class="string">"AAA1"</span></span><br></pre></td></tr></table></figure>
<p>Match 匹配</p>
<p>Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是最终操作，并返回一个boolean类型的值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">boolean anyStartsWithA = </span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .anyMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</span><br><span class="line"> </span><br><span class="line">System.out.println(anyStartsWithA);      // <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line">boolean allStartsWithA = </span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .allMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</span><br><span class="line"> </span><br><span class="line">System.out.println(allStartsWithA);      // <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line">boolean noneStartsWithZ = </span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .noneMatch((s) -&gt; s.startsWith(<span class="string">"z"</span>));</span><br><span class="line"> </span><br><span class="line">System.out.println(noneStartsWithZ);      // <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>Count 计数</p>
<p>计数是一个最终操作，返回Stream中元素的个数，返回值类型是long。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long startsWithB = </span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .filter((s) -&gt; s.startsWith(<span class="string">"b"</span>))</span><br><span class="line">        .count();</span><br><span class="line"> </span><br><span class="line">System.out.println(startsWithB);    // 3</span><br></pre></td></tr></table></figure></p>
<p>Reduce 规约</p>
<p>这是一个最终操作，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Optional&lt;String&gt; reduced =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .sorted()</span><br><span class="line">        .reduce((s1, s2) -&gt; s1 + <span class="string">"#"</span> + s2);</span><br><span class="line"> </span><br><span class="line">reduced.ifPresent(System.out::println);</span><br><span class="line">// <span class="string">"aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2"</span></span><br></pre></td></tr></table></figure></p>
<p>并行Streams</p>
<p>前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。</p>
<p>下面的例子展示了是如何通过并行Stream来提升性能：</p>
<p>首先我们创建一个没有重复元素的大表：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int max = 1000000;</span><br><span class="line">List&lt;String&gt; values = new ArrayList&lt;&gt;(max);</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; max; i++) &#123;</span><br><span class="line">    UUID uuid = UUID.randomUUID();</span><br><span class="line">    values.add(uuid.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们计算一下排序这个Stream要耗时多久，<br>串行排序：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">long t0 = System.nanoTime();</span><br><span class="line"> </span><br><span class="line">long count = values.stream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"> </span><br><span class="line">long t1 = System.nanoTime();</span><br><span class="line"> </span><br><span class="line">long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">"sequential sort took: %d ms"</span>, millis));</span><br></pre></td></tr></table></figure></p>
<p>// 串行耗时: 899 ms<br>并行排序：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">long t0 = System.nanoTime();</span><br><span class="line"> </span><br><span class="line">long count = values.parallelStream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"> </span><br><span class="line">long t1 = System.nanoTime();</span><br><span class="line"> </span><br><span class="line">long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">"parallel sort took: %d ms"</span>, millis));</span><br></pre></td></tr></table></figure></p>
<p>// 并行排序耗时: 472 ms<br>上面两个代码几乎是一样的，但是并行版的快了50%之多，唯一需要做的改动就是将stream()改为parallelStream()。</p>
<p>Map</p>
<p>前面提到过，Map类型不支持stream，不过Map提供了一些新的有用的方法来处理一些日常任务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    map.putIfAbsent(i, <span class="string">"val"</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>map.forEach((id, val) -&gt; System.out.println(val));<br>以上代码很容易理解， putIfAbsent 不需要我们做额外的存在性检查，而forEach则接收一个Consumer接口来对map里的每一个键值对进行操作。</p>
<p>下面的例子展示了map上的其他有用的函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">map.computeIfPresent(3, (num, val) -&gt; val + num);</span><br><span class="line">map.get(3);             // val33</span><br><span class="line"> </span><br><span class="line">map.computeIfPresent(9, (num, val) -&gt; null);</span><br><span class="line">map.containsKey(9);     // <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line">map.computeIfAbsent(23, num -&gt; <span class="string">"val"</span> + num);</span><br><span class="line">map.containsKey(23);    // <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line">map.computeIfAbsent(3, num -&gt; <span class="string">"bam"</span>);</span><br><span class="line">map.get(3);             // val33</span><br></pre></td></tr></table></figure>
<p>接下来展示如何在Map里删除一个键值全都匹配的项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map.remove(3, <span class="string">"val3"</span>);</span><br><span class="line">map.get(3);             // val33</span><br><span class="line"> </span><br><span class="line">map.remove(3, <span class="string">"val33"</span>);</span><br><span class="line">map.get(3);             // null</span><br></pre></td></tr></table></figure></p>
<p>另外一个有用的方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.getOrDefault(42, <span class="string">"not found"</span>);  // not found</span><br></pre></td></tr></table></figure></p>
<p>对Map的元素做合并也变得很容易了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map.merge(9, <span class="string">"val9"</span>, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(9);             // val9</span><br><span class="line"> </span><br><span class="line">map.merge(9, <span class="string">"concat"</span>, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(9);             // val9concat</span><br></pre></td></tr></table></figure>
<p>Merge做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。</p>
<p>九、Date API</p>
<p>Java 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分：</p>
<p>Clock 时钟</p>
<p>Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Clock clock = Clock.systemDefaultZone();</span><br><span class="line">long millis = clock.millis();</span><br><span class="line"> </span><br><span class="line">Instant instant = clock.instant();</span><br><span class="line">Date legacyDate = Date.from(instant);   // legacy java.util.Date</span><br></pre></td></tr></table></figure></p>
<p>Timezones 时区</p>
<p>在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">System.out.println(ZoneId.getAvailableZoneIds());</span><br><span class="line">// prints all available timezone ids</span><br><span class="line"> </span><br><span class="line">ZoneId zone1 = ZoneId.of(<span class="string">"Europe/Berlin"</span>);</span><br><span class="line">ZoneId zone2 = ZoneId.of(<span class="string">"Brazil/East"</span>);</span><br><span class="line">System.out.println(zone1.getRules());</span><br><span class="line">System.out.println(zone2.getRules());</span><br><span class="line"> </span><br><span class="line">// ZoneRules[currentStandardOffset=+01:00]</span><br><span class="line">// ZoneRules[currentStandardOffset=-03:00]</span><br></pre></td></tr></table></figure>
<p>LocalTime 本地时间</p>
<p>LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LocalTime now1 = LocalTime.now(zone1);</span><br><span class="line">LocalTime now2 = LocalTime.now(zone2);</span><br><span class="line"> </span><br><span class="line">System.out.println(now1.isBefore(now2));  // <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line">long hoursBetween = ChronoUnit.HOURS.between(now1, now2);</span><br><span class="line">long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</span><br><span class="line"> </span><br><span class="line">System.out.println(hoursBetween);       // -3</span><br><span class="line">System.out.println(minutesBetween);     // -239</span><br></pre></td></tr></table></figure>
<p>LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LocalTime late = LocalTime.of(23, 59, 59);</span><br><span class="line">System.out.println(late);       // 23:59:59</span><br><span class="line"> </span><br><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofLocalizedTime(FormatStyle.SHORT)</span><br><span class="line">        .withLocale(Locale.GERMAN);</span><br><span class="line"> </span><br><span class="line">LocalTime leetTime = LocalTime.parse(<span class="string">"13:37"</span>, germanFormatter);</span><br><span class="line">System.out.println(leetTime);   // 13:37</span><br></pre></td></tr></table></figure></p>
<p>LocalDate 本地日期</p>
<p>LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);</span><br><span class="line">LocalDate yesterday = tomorrow.minusDays(2);</span><br><span class="line"> </span><br><span class="line">LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);</span><br><span class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</span><br></pre></td></tr></table></figure></p>
<p>System.out.println(dayOfWeek);    // FRIDAY<br>从字符串解析一个LocalDate类型和解析LocalTime一样简单：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofLocalizedDate(FormatStyle.MEDIUM)</span><br><span class="line">        .withLocale(Locale.GERMAN);</span><br><span class="line"> </span><br><span class="line">LocalDate xmas = LocalDate.parse(<span class="string">"24.12.2014"</span>, germanFormatter);</span><br><span class="line">System.out.println(xmas);   // 2014-12-24</span><br></pre></td></tr></table></figure></p>
<p>LocalDateTime 本地日期时间</p>
<p>LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);</span><br><span class="line"> </span><br><span class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);      // WEDNESDAY</span><br><span class="line"> </span><br><span class="line">Month month = sylvester.getMonth();</span><br><span class="line">System.out.println(month);          // DECEMBER</span><br><span class="line"> </span><br><span class="line">long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</span><br><span class="line">System.out.println(minuteOfDay);    // 1439</span><br></pre></td></tr></table></figure></p>
<p>只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Instant instant = sylvester</span><br><span class="line">        .atZone(ZoneId.systemDefault())</span><br><span class="line">        .toInstant();</span><br><span class="line"> </span><br><span class="line">Date legacyDate = Date.from(instant);</span><br><span class="line">System.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014</span><br></pre></td></tr></table></figure></p>
<p>格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofPattern(<span class="string">"MMM dd, yyyy - HH:mm"</span>);</span><br><span class="line"> </span><br><span class="line">LocalDateTime parsed = LocalDateTime.parse(<span class="string">"Nov 03, 2014 - 07:13"</span>, formatter);</span><br><span class="line">String string = formatter.format(parsed);</span><br><span class="line">System.out.println(string);     // Nov 03, 2014 - 07:13</span><br></pre></td></tr></table></figure>
<p>和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。<br>关于时间日期格式的详细信息：<a href="http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html" target="_blank" rel="external">http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html</a></p>
<p>十、Annotation 注解<br>在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。<br>首先定义一个包装类Hints注解用来放置一组具体的Hint注解：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface Hints &#123;</span><br><span class="line">    Hint[] value();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@Repeatable(Hints.class)</span><br><span class="line">@interface Hint &#123;</span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。</p>
<p>例 1: 使用包装类当容器来存多个注解（老方法）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Hints(&#123;@Hint(<span class="string">"hint1"</span>), @Hint(<span class="string">"hint2"</span>)&#125;)</span><br><span class="line">class Person &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>例 2：使用多重注解（新方法）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Hint(<span class="string">"hint1"</span>)</span><br><span class="line">@Hint(<span class="string">"hint2"</span>)</span><br><span class="line">class Person &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你<br>用反射来获取这些信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Hint hint = Person.class.getAnnotation(Hint.class);</span><br><span class="line">System.out.println(hint);                   // null</span><br><span class="line"> </span><br><span class="line">Hints hints1 = Person.class.getAnnotation(Hints.class);</span><br><span class="line">System.out.println(hints1.value().length);  // 2</span><br><span class="line"> </span><br><span class="line">Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);</span><br><span class="line">System.out.println(hints2.length);          // 2</span><br></pre></td></tr></table></figure></p>
<p>即便我们没有在Person类上定义@Hints注解，我们还是可以通过 getAnnotation(Hints.class) 来获取 @Hints注解，更加方便的方法是使用 getAnnotationsByType 可以直接获取到所有的@Hint注解。<br>另外Java 8的注解还增加到两种新的target上了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)</span><br><span class="line">@interface MyAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>关于Java 8的新特性就写到这了，肯定还有更多的特性等待发掘。JDK 1.8里还有很多很有用的东西，比如Arrays.parallelSort, StampedLock和CompletableFuture等等。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java中Sort方法底层实现]]></title>
      <url>http://yoursite.com/2016/03/22/java%E4%B8%ADSort%E6%96%B9%E6%B3%95%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<p>java中Arrays.sort使用了两种排序方法，快速排序和优化的合并排序。<br><a id="more"></a><br>快速排序主要是对哪些基本类型数据（int,short,long等）排序， 而合并排序用于对对象类型进行排序。<br>使用不同类型的排序算法主要是由于快速排序是不稳定的，而合并排序是稳定的。这里的稳定是指比较相等的数据在排序之后仍然按照排序之前的前后顺序排列。对于基本数据类型，稳定性没有意义，而对于对象类型，稳定性是比较重要的，因为对象相等的判断可能只是判断关键属性，最好保持相等对象的非关键属性的顺序与排序前一直；另外一个原因是由于合并排序相对而言比较次数比快速排序少，移动（对象引用的移动）次数比快速排序多，而对于对象来说，比较一般比移动耗时。<br>补充一点合并排序的时间复杂度是n<em>logn, 快速排序的平均时间复杂度也是n</em>logn，但是合并排序的需要额外的n个引用的空间 ……<br>转自：<a href="http://blog.sina.com.cn/s/blog_7337d6a00100xpd5.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_7337d6a00100xpd5.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ArrayList和Vector的区别]]></title>
      <url>http://yoursite.com/2016/03/21/ArrayList%E5%92%8CVector%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>这两个类都实现了List接口（List接口继承了Collection接口），他们都是有序集合，级存贮在这两个集合中的元素都是有序的，他们的底层实现就是用数组。我们可以按照集合中元素的索引号取出某个元素，并且其中元素是可以重复的（比较和HashTable以及HashMap的区别）。<br><a id="more"></a></p>
<p>接下来我们详细说明两者的区别：<br>1 同步性<br>    Vector是线程安全的，也就是说他的方法之间是线程同步的，而Arraylist是线程不安全的，他的方法之间不是线程同步的，如果只有一个线程会访问到集合，那么我们就应该用ArrayList，因为他不需要考虑线程的安全性，效率更高；如果有多个线程访问该集合，那么最好使用Vector，因为他是贤臣安全的，我们就不要在考虑和编写线程安全的代码。</p>
<p>2 数据增长<br>    Arraylist与Vector都有一个初始的容量大小，当存储在他们里边的元素的个数超过了该容量，就需要增加ArrayList和Vector的大小，每次要增加存储空间的时候，不是增加一个存储空间，而是增加多个存储空间，Vector增加默认增加为原来的两倍，Arraylist增加为原来的1.5倍（在源码中可以看到）。他们也可以设置增长空间大小，比如用resize方法</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Comparable和Comparator的区别]]></title>
      <url>http://yoursite.com/2016/03/21/Comparable%E5%92%8CComparator%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>Comparator和Comparable 都是用来实现集合中元素的比较。排序的，知识，Comparable实现的排序实在java集合内部实现的，而Comparator的排序实在java集合外部实现的排序，所以，如果想实现排序，那就需要在集合内实现Comparable接口或者在集合外部实现Comparator接口<br>另外，就从所处的包来说： Comparator位于java.util下，而Comparable位于包java.lang下<br>下边我们详细说下两者的异同：<br><a id="more"></a><br>1 Comaprable和Comaprator相同的地方</p>
<p>他们都是一个java接口，并且都是用来对定义的class比较大小的，什么是是自定义的class，如public class person {。。。}<br> 当我们有这么一个personList,里面包含了person1, person2, persion3….., 我们用Collections.sort( personList ),<br>是得不到预期的结果的. 这时肯定有人要问, 那为什么可以排序一个字符串list呢:</p>
<p>如 StringList{“hello1” , “hello3” , “hello2”}, Collections.sort( stringList ) 能够得到正确的排序, 那是因为<br>String 这个对象已经帮我们实现了 Comparable接口 , 所以我们的 Person 如果想排序, 也要实现一个比较器。</p>
<ol>
<li>Comparator 和 Comparable 的区别</li>
</ol>
<p>Comparable</p>
<p>Comparable 定义在 Person类的内部:</p>
<p>public class Persion implements Comparable {..比较Person的大小..},</p>
<p> 因为已经实现了比较器,那么我们的Person现在是一个可以比较大小的对象了,它的比较功能和String完全一样,可以随时随地的拿来<br>比较大小,因为Person现在自身就是有大小之分的。Collections.sort(personList)可以得到正确的结果。</p>
<p>Comparator</p>
<p>Comparator 是定义在Person的外部的, 此时我们的Person类的结构不需要有任何变化,如</p>
<p>public class Person{ String name; int age },</p>
<p>然后我们另外定义一个比较器:</p>
<p>public PersonComparator implements Comparator() {..比较Person的大小..},</p>
<p>在PersonComparator里面实现了怎么比较两个Person的大小. 所以,用这种方法,当我们要对一个 personList进行排序的时候,<br>我们除了了要传递personList过去, 还需要把PersonComparator传递过去,因为怎么比较Person的大小是在PersonComparator<br>里面实现的, 如:</p>
<p>Collections.sort( personList , new PersonComparator() ).</p>
<ol>
<li>Comparator 和 Comparable 的实例</li>
</ol>
<p>Comparable:</p>
<p>实现Comparable接口要覆盖compareTo方法, 在compareTo方法里面实现比较：<br>public class Person implements Comparable {<br>     String name;<br>     int age<br>     public int compareTo(Person another) {<br>          int i = 0;<br>          i = name.compareTo(another.name); // 使用字符串的比较<br>          if(i == 0) { // 如果名字一样,比较年龄, 返回比较年龄结果<br>               return age - another.age;<br>          } else {<br>               return i; // 名字不一样, 返回比较名字的结果.<br>          }<br>     }<br>}<br>   这时我们可以直接用 Collections.sort( personList ) 对其排序了.</p>
<p>Comparator:</p>
<p>实现Comparator需要覆盖 compare 方法：<br>public class Person{<br>     String name;<br>     int age<br>}</p>
<p>class PersonComparator implements Comparator {<br>     public int compare(Person one, Person another) {<br>          int i = 0;<br>          i = one.name.compareTo(another.name); // 使用字符串的比较<br>          if(i == 0) { // 如果名字一样,比较年龄,返回比较年龄结果<br>               return one.age - another.age;<br>          } else {<br>               return i; // 名字不一样, 返回比较名字的结果.<br>          }<br>     }<br>}<br>   Collections.sort( personList , new PersonComparator()) 可以对其排序</p>
<p> 4:总结</p>
<p>两种方法各有优劣, 用Comparable 简单, 只要实现Comparable 接口的对象直接就成为一个可以比较的对象,<br>但是需要修改源代码, 用Comparator 的好处是不需要修改源代码, 而是另外实现一个比较器, 当某个自定义<br>的对象需要作比较的时候,把比较器和对象一起传递过去就可以比大小了, 并且在Comparator 里面用户可以自<br>己实现复杂的可以通用的逻辑,使其可以匹配一些比较简单的对象,那样就可以节省很多重复劳动了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[多线程对文件的读写]]></title>
      <url>http://yoursite.com/2016/03/21/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99/</url>
      <content type="html"><![CDATA[<p>题目：<br> 一个文件中有10000个数，用java实现一个多线程程序将这10000个数输入到五个不同的文件中（要求输入到每个文件中的数量相同）。要求启动10个线程，两两一组，分为五组。每组两个线程分别将文件中的奇数偶数输入到改组对应的文件中，需要偶数线程没打印10个偶数之后，就将技术线程打印10个奇数，如此交替进行。同时需要记录输入进度，没完成1000个数就在控制台打印当前完成的数量，并在所有线程结束后，在控制台打印”DONE”。</p>
<p> 分析：（1）我们可以将10000个数字分成五份，每一份对应两个线程，每两个线程对应一个打印类实体（2）同时声明一个共享变量，用于记录当前线程输出的记录数，但应记录的输出进度；</p>
<p> 代码如下：<br> <a id="more"></a><br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"> import java.io.BufferedReader;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.FileReader;</span><br><span class="line">import java.io.FileWriter;</span><br><span class="line">import java.io.PrintWriter;</span><br><span class="line">import java.util.Random;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> 一个文件中有10000个数，用Java实现一个多线程程序将这个10000个数输出到5个不用文件中（不要求输出到每个文件中的数量相同）。</span><br><span class="line"> 要求启动10个线程，两两一组，分为5组。</span><br><span class="line"> 每组两个线程分别将文件中的奇数和偶数输出到该组对应的一个文件中，</span><br><span class="line"> 需要偶数线程每打印10个偶数以后，就将奇数线程打印10个奇数，如此交替进行。</span><br><span class="line"> 同时需要记录输出进度，每完成1000个数就在控制台中打印当前完成数量，并在所有线程结束后，在控制台打印”Done”.</span><br><span class="line"> */</span><br><span class="line">/**</span><br><span class="line"> * 分析：可以将10000个数分成5份，每一份（2000个数）对应一组，即两个线程，来分别输出这一份的奇数和偶数，</span><br><span class="line"> * 同时声明一个共享变量，用于统计当前所有线程输出的个数，反映记录的输出进度</span><br><span class="line"> */</span><br><span class="line">public class PrintByThread &#123;</span><br><span class="line">     </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //创建一个包含10000数字的输入文件</span><br><span class="line">            PrintWriter pw=new PrintWriter(new FileWriter(new File(<span class="string">"input.txt"</span>)),<span class="literal">true</span>);</span><br><span class="line">            Random random=new Random();</span><br><span class="line">            <span class="keyword">for</span> (int i = 0; i &lt; 10000; i++) &#123;</span><br><span class="line">                pw.print(Math.abs(random.nextInt())%100+<span class="string">","</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            pw.flush();</span><br><span class="line">            pw.close();</span><br><span class="line">            //读取文件中的数字，分5次读取，每次读取2000个</span><br><span class="line">            BufferedReader reader=new BufferedReader(new FileReader(<span class="string">"input.txt"</span>));</span><br><span class="line">            String str=reader.readLine();</span><br><span class="line">            reader.close();</span><br><span class="line">            String[] strs=str.split(<span class="string">","</span>);//将一行字符串全部解析为10000个数字</span><br><span class="line">            int j=0;//10000个数的索引计数</span><br><span class="line">            <span class="keyword">for</span> (int i = 0; i &lt; 5; i++) &#123;</span><br><span class="line">                int records[]=new int[2000];</span><br><span class="line">                <span class="keyword">for</span> (int k = 0; k &lt; 2000; k++) &#123;</span><br><span class="line">                    records[k]=Integer.parseInt(strs[j]);</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                //定义输出文件</span><br><span class="line">                PrintWriter writer = new PrintWriter(new FileWriter(new File(<span class="string">"output"</span>+i+<span class="string">".txt"</span>)),<span class="literal">true</span>);</span><br><span class="line">                //定义实现的方法</span><br><span class="line">                ThreadGroup3 group = new ThreadGroup3(records, writer);</span><br><span class="line">                //开启一对儿线程</span><br><span class="line">                new Thread(group).start();</span><br><span class="line">                new Thread(group).start();    </span><br><span class="line">            &#125;          </span><br><span class="line">             </span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // TODO: handle exception</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">class ThreadGroup3 implements Runnable&#123;</span><br><span class="line">    //所有类对象共享的同一个计数器count，记录总共输出的记录总数</span><br><span class="line">    private static int count=0;</span><br><span class="line">    //所有的ThreadGroup类对象共享一个锁，用于count变量的同步，任何一个线程需要修改count变量，必须取得该锁</span><br><span class="line">    private static Object lock=new Object();</span><br><span class="line">    public static final int EVEN=0;//代表偶数</span><br><span class="line">    public static final int ODD=-1;//代表奇数（此处一定要是-1，因为后边 <span class="built_in">type</span> = ~ <span class="built_in">type</span>的代码，0的按位取反（~）结果是-1，切记切记）</span><br><span class="line">     </span><br><span class="line">    //*********以上静态变量，属于整个类所有***********</span><br><span class="line">    private int <span class="built_in">type</span>;</span><br><span class="line">    private int records[];</span><br><span class="line">    private PrintWriter writer;//每组共享一个writer，输出到同一个文件</span><br><span class="line">    private int oddPoint=0;//记录每次打印奇数的起始位置</span><br><span class="line">    private int evenPoint=0;//记录每次打印偶数的起始位置</span><br><span class="line">     </span><br><span class="line">    public ThreadGroup3(int[] records,PrintWriter writer)&#123;</span><br><span class="line">        this.records=records;</span><br><span class="line">        this.writer=writer;</span><br><span class="line">        this.type=EVEN;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    //线程方法实现</span><br><span class="line">    public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">print</span>());</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    private synchronized boolean <span class="function"><span class="title">print</span></span>()&#123;</span><br><span class="line">        <span class="keyword">for</span>(int i=0;i&lt;10;)&#123;</span><br><span class="line">            //如果奇数和偶数都打印完成以后，就直接停止打印循环，等待该线程自己结束</span><br><span class="line">            <span class="keyword">if</span> (oddPoint&gt;=records.length&amp;&amp;evenPoint&gt;=records.length) &#123;</span><br><span class="line">                notifyAll();</span><br><span class="line">                <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //如果该线程该打印奇数，但奇数已经打印晚了，就直接停止本次10个数的打印，</span><br><span class="line">            //同理偶数，等下次切换打印类型后，再开始打印另外一种类型</span><br><span class="line">            <span class="keyword">if</span> ((oddPoint&gt;=records.length&amp;&amp;<span class="built_in">type</span>==ODD)||(evenPoint&gt;=records.length&amp;&amp;<span class="built_in">type</span>==EVEN)) &#123;</span><br><span class="line">                <span class="built_in">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            //判断开始打印偶数</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">type</span>==EVEN) &#123;</span><br><span class="line">                <span class="keyword">if</span> (records[evenPoint]%2==0) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    writer.print(records[evenPoint]+<span class="string">","</span>);</span><br><span class="line">                    writer.flush();</span><br><span class="line">                    //锁定全局变量方便线程输出后计数</span><br><span class="line">                    synchronized (lock) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                        <span class="keyword">if</span> (count%1000==0) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"当前完成数量："</span>+count);</span><br><span class="line">                            <span class="keyword">if</span> (count==10000) &#123;</span><br><span class="line">                                System.out.println(<span class="string">"Done!"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //无论是否是偶数，打印成功一个后，偶数的起始位置都要后移</span><br><span class="line">                evenPoint++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                //打印奇数</span><br><span class="line">                <span class="keyword">if</span> (records[oddPoint]%2==1) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    writer.print(records[oddPoint]+<span class="string">","</span>);</span><br><span class="line">                    writer.flush();</span><br><span class="line">                    //锁定全局变量方便线程输出后计数</span><br><span class="line">                    synchronized (lock) &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                        <span class="keyword">if</span> (count%1000==0) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"当前完成数量："</span>+count);</span><br><span class="line">                            <span class="keyword">if</span> (count==10000) &#123;</span><br><span class="line">                                System.out.println(<span class="string">"Done!"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                //无论是否是奇数，打印成功一个后，偶数的起始位置都要后移</span><br><span class="line">                oddPoint++;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">type</span>=~<span class="built_in">type</span>;//切换打印类型</span><br><span class="line">        notifyAll();//一组中的任一线程打印完后唤醒另一个线程</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="built_in">wait</span>();//释放锁进入等待状态，等待另一线程打印</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // TODO: handle exception</span><br><span class="line">        	e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>（以下结果是完全真实运行的结果，读者可以拿来验证）<br> 在控制台的输出结果：<br>当前完成数量：1000<br>当前完成数量：2000<br>当前完成数量：3000<br>当前完成数量：4000<br>当前完成数量：5000<br>当前完成数量：6000<br>当前完成数量：7000<br>当前完成数量：8000<br>当前完成数量：9000<br>当前完成数量：10000<br>Done!</p>
<p>在input.txt中，部分数据内容如下：<br><img src="/images/input.png" alt="Alt text"></p>
<p>在output0.txt文件中，部分内容如下：<br><img src="/images/output0.png" alt="Alt text"><br>在input1.txt文件中，内容和在output0.txt内容相似，这里不再赘述。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在try-catch-finally中关于return语句是否立即返回]]></title>
      <url>http://yoursite.com/2016/03/15/%E5%9C%A8try-catch-finally%E4%B8%AD%E5%85%B3%E4%BA%8Ereturn%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%90%A6%E7%AB%8B%E5%8D%B3%E8%BF%94%E5%9B%9E/</url>
      <content type="html"><![CDATA[<p>java的return语句，好多程序员都认为自己对这个语句很了解，可是，事实是这样吗？请看下边的一个例子：<br><a id="more"></a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TestClass &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		TestClass tc = new TestClass();</span><br><span class="line">		int b = tc.getInt();</span><br><span class="line">		System.out.println(b);</span><br><span class="line">	&#125;</span><br><span class="line">	public int <span class="function"><span class="title">getInt</span></span>() &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			<span class="built_in">return</span> 1;</span><br><span class="line">		&#125;finally &#123;</span><br><span class="line">			<span class="built_in">return</span> 2;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述程序打印的结果是什么呢？<br>答案是 2 </p>
<p>为什么是2呢？ 这是因为，就好像是为主函数准备了一个容器，在调用子函数的过程中，遇到return语句，并不是立即返回，而是把结果放到函数栈中，此时的函数也不是立即返回，而是等到finally语句执行完后，才会真正返回。所以在finally语句结束后，返回结果是2，把2放入到函数栈中覆盖第一个返回值1，那么，程序的输出结果就是2了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[内部类详解]]></title>
      <url>http://yoursite.com/2016/03/14/%E5%86%85%E9%83%A8%E7%B1%BB%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>java的内部类详解<br>java的内部类，就是一个类的内部定义的类。这个类可以是可以是Inner Class，也可以是Static Nested Class。<br><a id="more"></a><br>内部类可以定义外部类方法的外面，也可以定义在外部类的方法的里边，##内部类可以直接访问外部类的成员变量。##如下代码：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">	private int out_x = 0;</span><br><span class="line">		public void <span class="function"><span class="title">method1</span></span>() &#123;</span><br><span class="line">			InnerClass2 inner2 = new InnerClass2();//内部类2实例化</span><br><span class="line">			class InnerClass1 &#123;//定义内部类1</span><br><span class="line">				public void <span class="function"><span class="title">method2</span></span>() &#123;</span><br><span class="line">					out_x = 3;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			InnerClass1 inner1 = new InnerClass1();//内部类1实例化</span><br><span class="line">		&#125;</span><br><span class="line">		public class innerClass2 &#123;内部类2定义</span><br><span class="line">			public void <span class="function"><span class="title">method2</span></span>() &#123;</span><br><span class="line">				out_x = 10;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在方法体的外部可以定义内部类，如InnerClass2，在方法体的内部也可以定义内部类，如innerClass1。在方法体的外部定义的内部类的内部类可用public，private,默认和protected修饰，他决定内部类对外是不是可见。我们要是想得到外部类的实例，必须先把外部类实例化，然后在实例化内部类；如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OuterClass outer = new Outer();</span><br><span class="line">Outer.InnerClass2 = outer.new Inner1();</span><br></pre></td></tr></table></figure></p>
<p>定义在方法体内部的内部类，是不能有任何的修饰符，这是和方法体内部的局部变量是一样的。但是这种内部类是可以用final和abstract修饰的。这种内部类对外部是不可见的。但是可以通过对该类的实例化，把内部类传递给外部进行使用。该内部类必须遵循先定义在使用的原则，通俗上说就是内部类的定义代码必须在实用类代码之前。这种规则和方法中的局部变量是一样的。这种内部类是可以访问方法中的局部变量的，但是该局部变量之前必须加final修饰符（建议在eclipse上练练就明白了）。</p>
<p>下边说下匿名内部类：<br>有时候我们我们使用内部类并不需要他的名字，这种内部类就是匿名内部类。定义的方法就是在定义在定义某一个接口或者某一个类的子类时，还创建了该类的实例对象。这时是不用给内部类命名的。例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class OuterClass &#123;</span><br><span class="line">	public void <span class="function"><span class="title">method</span></span>() &#123;</span><br><span class="line">		new Thread(</span><br><span class="line">			new <span class="function"><span class="title">Runable</span></span>() &#123;</span><br><span class="line">				public void <span class="function"><span class="title">run</span></span>()&#123;&#125;;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后来说下，static Nested class 和 inner class的区别；<br>在方法体的外部定义的内部类加上static关键字，从而成为Static Nested Class。这样的类其实就不在具备内部类的特性。static Nested class在运行上和普通类没有什么区别。只是在定义时，修饰符可以是public protected 默认的和private的。而普通类只能是public和默认的。这里要是想访问static Nested class类，就不需要依靠外部类的实体。通过”外部类名.内部类名”就可以直接创建该内部类的实体。所用的方法是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outer outer = new OuterClass.innerClass();</span><br></pre></td></tr></table></figure></p>
<p>Static Nested Class 类可以访问外部类的非Static变量，但是不是直接访问，必须是建立外部类的实例，通过外部类实例进行访问。</p>
<p>在静态方法中定义的内部类也是Static Nested Class类，这个方法前边不能再加static关键字。此类和普通方法中的类的使用方式很相似。例如：都可以访问外部类中的成员变量，可以访问方法中的局部变量，但是该变量必须用final修饰；</p>
]]></content>
    </entry>
    
  
  
</search>
