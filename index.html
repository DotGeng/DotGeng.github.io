<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8" />
  
  <title>DotGeng</title>
  <meta name="author" content="Gengyukun" />

  
  <meta name="description" content="DotGeng的Blog" />
  

  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  
  <meta property="og:site_name" content="DotGeng" />

  
  

  
    <meta property="og:image" content="undefined" />
  

  
  <link href="/css/images/favicon.ico" rel="icon" />
  

  <link rel="alternate" href="/atom.xml" title="DotGeng" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  


  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>

</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">DotGeng</a></h1>
  <h2><a href="/"></a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-11T14:27:39.000Z"><a href="/2016/04/11/java主函数所在类的思考/">2016-04-11</a></time>
      
      
  
    <h1 class="title"><a href="/2016/04/11/java主函数所在类的思考/">java主函数所在类的思考</a></h1>
  

    </header>
    <div class="entry">
      
        <p>今天跟同学突然聊到关于java的main函数所在类的实例化问题；他突然问我，在程序运行时候，main函数所在的类是否会实例化，我还真一时脑袋没转过来，不过，还来想想，这个问题还是挺简单的。</p>
<p>main函数所在类是否实例化，还是看你是否用法哦了该类的实例，是否写了new方法。</p>
<p>其实，main所在的类和其他类没有什么区别，只是main函数式程序的入口。在程序启动时候，调用main函数。因为main函数是static的，所以，其所在的类及时不实例化，他也可以运行。当你用到该类的实例的时候，你会new出一个实例，这时候main函数所在类就实例化了。如果你没有用到该类的实例，那么你就不需要new出这么个实例，所以，这个时候就没有实例化main函数所在的类。</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/技术/">技术</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/java基础/">java基础</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-04-01T07:28:13.000Z"><a href="/2016/04/01/MySql外键设置中的Cascade-no-action-restrict-set-null-分享/">2016-04-01</a></time>
      
      
  
    <h1 class="title"><a href="/2016/04/01/MySql外键设置中的Cascade-no-action-restrict-set-null-分享/">MySql外键设置中的Cascade, no action,restrict ,set null(分享)</a></h1>
  

    </header>
    <div class="entry">
      
        <p>今天项目的需要，需要mYSql数据库表中添加一些外键约束，本人由于对数据库的外键长时间不使用，已经全部归还给了老师，这次通过查找资料，也终于回想起来了，在这了分享给大家</p>
<p>cascade 方式：<br> 在父表上做更新或者删除的时候，同步更新或者删除子表的匹配记录；</p>
<p> no action方式<br> 如果子表中有匹配记录，那么则不允许对父表对应的候选键进行更新删除。</p>
<p> restrict 方式<br> 同 no action,都是直接检查外键约束，如果有外键约束的话，就拒绝父表进行相应的更新删除。</p>
<p>set null方式<br> 在父表上更新或者删除记录的时候，将子表上匹配记录的列设置为null；这里设计表的时候要注意，子表的外键列不能为null;</p>
<p> 还有一种是set default 方式</p>
<p> 父表有更新的时候，子表将外键类设置为一个默认的值。</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
        
  
  <div class="tags">
    <a href="/tags/分享/">分享</a>, <a href="/tags/数据库/">数据库</a>, <a href="/tags/object-Object/">[object Object]</a>, <a href="/tags/技术/">技术</a>, <a href="/tags/随笔/">随笔</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-03-30T14:24:04.000Z"><a href="/2016/03/30/Java对象池技术的原理及其实现-转载/">2016-03-30</a></time>
      
      
  
    <h1 class="title"><a href="/2016/03/30/Java对象池技术的原理及其实现-转载/">Java对象池技术的原理及其实现(转载)</a></h1>
  

    </header>
    <div class="entry">
      
        <p>今天给大家分享下Java对象池技术的一些知识：</p>
<p>本文在分析对象池技术基本原理的基础上，给出了对象池技术的两种实现方式。还指出了使用对象池技术时所应注意的问题。<br>Java对象的生命周期分析</p>
<p>　　Java对象的生命周期大致包括三个阶段：对象的创建，对象的使用，对象的清除。因此，对象的生命周期长度可用如下的表达式表示：T = T1 + T2 +T3。其中T1表示对象的创建时间，T2表示对象的使用时间，而T3则表示其清除时间。由此，我们可以看出，只有T2是真正有效的时间，而T1、T3则是对象本身的开销。下面再看看T1、T3在对象的整个生命周期中所占的比例。</p>
<p>　　我们知道，Java对象是通过构造函数来创建的，在这一过程中，该构造函数链中的所有构造函数也都会被自动调用。另外，默认情况下，调用类的构造函数时，Java会把变量初始化成确定的值：所有的对象被设置成null，整数变量（byte、short、int、long）设置成0，float和double变量设置成0.0，逻辑值设置成false。所以用new关键字来新建一个对象的时间开销是很大的，如表1所示。</p>
<p>表1 一些操作所耗费时间的对照表</p>
<p>运算操作    示例    标准化时间<br>本地赋值    i = n        1.0<br>实例赋值    this.i = n    1.2<br>方法调用    Funct()        5.9<br>新建对象    New Object()    980<br>新建数组    New int[10]    3100</p>
<p>从表1可以看出，新建一个对象需要980个单位的时间，是本地赋值时间的980倍，是方法调用时间的166倍，而若新建一个数组所花费的时间就更多了。</p>
<p>再看清除对象的过程。我们知道，Java语言的一个优势，就是Java程序员勿需再像C/C++程序员那样，显式地释放对象，而由称为垃圾收集器（Garbage Collector）的自动内存管理系统，定时或在内存凸现出不足时，自动回收垃圾对象所占的内存。凡事有利总也有弊，这虽然为Java程序设计者提供了极大的方便，但同时它也带来了较大的性能开销。这种开销包括两方面，首先是对象管理开销，GC为了能够正确释放对象，它必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等。其次，在GC开始回收“垃圾”对象时，系统会暂停应用程序的执行，而独自占用CPU。</p>
<p>　　因此，如果要改善应用程序的性能，一方面应尽量减少创建新对象的次数；同时，还应尽量减少T1、T3的时间，而这些均可以通过对象池技术来实现。</p>
<p>　　对象池技术的基本原理</p>
<p>　　对象池技术基本原理的核心有两点：缓存和共享，即对于那些被频繁使用的对象，在使用完后，不立即将它们释放，而是将它们缓存起来，以供后续的应用程序重复使用，从而减少创建对象和释放对象的次数，进而改善应用程序的性能。事实上，由于对象池技术将对象限制在一定的数量，也有效地减少了应用程序内存上的开销。</p>
<p>　　实现一个对象池，一般会涉及到如下的类：</p>
<p>　　1）对象池工厂（ObjectPoolFactory）类</p>
<p>　　该类主要用于管理相同类型和设置的对象池（ObjectPool），它一般包含如下两个方法：</p>
<p>　　·createPool：用于创建特定类型和设置的对象池；</p>
<p>　　·destroyPool：用于释放指定的对象池；</p>
<p>　　同时为保证ObjectPoolFactory的单一实例，可以采用Singleton设计模式，见下述getInstance方法的实现：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static ObjectPoolFactory <span class="function"><span class="title">getInstance</span></span>() &#123;</span><br><span class="line">　<span class="keyword">if</span> (poolFactory == null) &#123;</span><br><span class="line">　　poolFactory = new ObjectPoolFactory();</span><br><span class="line">　&#125;</span><br><span class="line">　<span class="built_in">return</span> poolFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　2）参数对象（ParameterObject）类</p>
<p>　　该类主要用于封装所创建对象池的一些属性参数，如池中可存放对象的数目的最大值（maxCount）、最小值（minCount）等。</p>
<p>　3）对象池（ObjectPool）类</p>
<p>　　用于管理要被池化对象的借出和归还，并通知PoolableObjectFactory完成相应的工作。它一般包含如下两个方法：</p>
<p>　　　·getObject：用于从池中借出对象；<br>　　　·returnObject：将池化对象返回到池中，并通知所有处于等待状态的线程；</p>
<p>　4）池化对象工厂（PoolableObjectFactory）类</p>
<p>　　该类主要负责管理池化对象的生命周期，就简单来说，一般包括对象的创建及销毁。该类同ObjectPoolFactory一样，也可将其实现为单实例。<br>　<br>通用对象池的实现</p>
<p>　　对象池的构造和管理可以按照多种方式实现。最灵活的方式是将池化对象的Class类型在对象池之外指定，即在ObjectPoolFactory类创建对象池时，动态指定该对象池所池化对象的Class类型，其实现代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public ObjectPool createPool(ParameterObject paraObj,Class clsType) &#123;</span><br><span class="line">　<span class="built_in">return</span> new ObjectPool(paraObj, clsType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，paraObj参数用于指定对象池的特征属性，clsType参数则指定了该对象池所存放对象的类型。对象池（ObjectPool）创建以后，下面就是利用它来管理对象了，具体实现如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectPool &#123;</span><br><span class="line">　private ParameterObject paraObj;//该对象池的属性参数对象</span><br><span class="line">　private Class clsType;//该对象池中所存放对象的类型</span><br><span class="line">　private int currentNum = 0; //该对象池当前已创建的对象数目</span><br><span class="line">　private Object currentObj;//该对象池当前可以借出的对象</span><br><span class="line">　private Vector pool;//用于存放对象的池</span><br><span class="line">　public ObjectPool(ParameterObject paraObj, Class clsType) &#123;</span><br><span class="line">　　this.paraObj = paraObj;</span><br><span class="line">　　this.clsType = clsType;</span><br><span class="line">　　pool = new Vector();</span><br><span class="line">　&#125;</span><br><span class="line">　public Object <span class="function"><span class="title">getObject</span></span>() &#123;</span><br><span class="line">　　<span class="keyword">if</span> (pool.size() &lt;= paraObj.getM<span class="keyword">in</span>Count()) &#123;</span><br><span class="line">　　　<span class="keyword">if</span> (currentNum &lt;= paraObj.getMaxCount()) &#123;</span><br><span class="line">　　　　//如果当前池中无对象可用，而且已创建的对象数目小于所限制的最大值，就利用</span><br><span class="line">　　　　//PoolObjectFactory创建一个新的对象</span><br><span class="line">　　　　PoolableObjectFactory objFactory =PoolableObjectFactory.getInstance();</span><br><span class="line">　　　　currentObj = objFactory.create Object (clsType);</span><br><span class="line">　　　　currentNum++;</span><br><span class="line">　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　//如果当前池中无对象可用，而且所创建的对象数目已达到所限制的最大值，</span><br><span class="line">　　　　//就只能等待其它线程返回对象到池中</span><br><span class="line">　　　　synchronized (this) &#123;</span><br><span class="line">　　　　　try &#123;</span><br><span class="line">　　　　　　<span class="built_in">wait</span>();</span><br><span class="line">　　　　　&#125; catch (InterruptedException e) &#123;</span><br><span class="line">　　　　　　System.out.println(e.getMessage());</span><br><span class="line">　　　　　　e.printStackTrace();</span><br><span class="line">　　　　　&#125;</span><br><span class="line">　　　　　currentObj = pool.firstElement();</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　&#125;</span><br><span class="line">　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　//如果当前池中有可用的对象，就直接从池中取出对象</span><br><span class="line">　　　currentObj = pool.firstElement();</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="built_in">return</span> currentObj;</span><br><span class="line">&#125;</span><br><span class="line">　　public void <span class="built_in">return</span>Object(Object obj) &#123;</span><br><span class="line">　　　// 确保对象具有正确的类型</span><br><span class="line">　　　<span class="keyword">if</span> (obj.isInstance(clsType)) &#123;</span><br><span class="line">　　　　pool.addElement(obj);</span><br><span class="line">　　　　synchronized (this) &#123;</span><br><span class="line">　　　　　notifyAll();</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">　　　　throw new IllegalArgumentException(<span class="string">"该对象池不能存放指定的对象类型"</span>);</span><br><span class="line">　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line">```bash</span><br><span class="line">　从上述代码可以看出，ObjectPool利用一个java.util.Vector作为可扩展的对象池，并通过它的构造函数来指定池化对象的Class类型及对象池的一些属性。在有对象返回到对象池时，它将检查对象的类型是否正确。当对象池里不再有可用对象时，它或者等待已被使用的池化对象返回池中，或者创建一个新的对象实例。不过，新对象实例的创建并不在ObjectPool类中，而是由PoolableObjectFactory类的createObject方法来完成的，具体实现如下：</span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line">public Object createObject(Class clsType) &#123;</span><br><span class="line">　Object obj = null;</span><br><span class="line">　try &#123;</span><br><span class="line">　　obj = clsType.newInstance();</span><br><span class="line">　&#125; catch (Exception e) &#123;</span><br><span class="line">　　e.printStackTrace();</span><br><span class="line">　&#125; </span><br><span class="line">　<span class="built_in">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>　这样，通用对象池的实现就算完成了，下面再看看客户端（Client）如何来使用它，假定池化对象的Class类型为StringBuffer：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//创建对象池工厂</span><br><span class="line">ObjectPoolFactory poolFactory = ObjectPoolFactory. getInstance ();</span><br><span class="line">//定义所创建对象池的属性</span><br><span class="line">ParameterObject paraObj = new ParameterObject(2,1);</span><br><span class="line">//利用对象池工厂,创建一个存放StringBuffer类型对象的对象池</span><br><span class="line">ObjectPool pool = poolFactory.createPool(paraObj,String Buffer.class);</span><br><span class="line">//从池中取出一个StringBuffer对象</span><br><span class="line">StringBuffer buffer = (StringBuffer)pool.getObject();</span><br><span class="line">//使用从池中取出的StringBuffer对象</span><br><span class="line">buffer.append(<span class="string">"hello"</span>);</span><br><span class="line">System.out.println(buffer.toString());</span><br></pre></td></tr></table></figure></p>
<p>　可以看出，通用对象池使用起来还是很方便的，不仅可以方便地避免频繁创建对象的开销，而且通用程度高。但遗憾的是，由于需要使用大量的类型定型（cast）操作，再加上一些对Vector类的同步操作，使得它在某些情况下对性能的改进非常有限，尤其对那些创建周期比较短的对象。</p>
<p>专用对象池的实现　　　　　</p>
<p>　　由于通用对象池的管理开销比较大，某种程度上抵消了重用对象所带来的大部分优势。为解决该问题，可以采用专用对象池的方法。即对象池所池化对象的Class类型不是动态指定的，而是预先就已指定。这样，它在实现上也会较通用对象池简单些，可以不要ObjectPoolFactory和PoolableObjectFactory类，而将它们的功能直接融合到ObjectPool类，具体如下（假定被池化对象的Class类型仍为StringBuffer，而用省略号表示的地方，表示代码同通用对象池的实现）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectPool &#123;</span><br><span class="line">　private ParameterObject paraObj;//该对象池的属性参数对象</span><br><span class="line">　private int currentNum = 0; //该对象池当前已创建的对象数目</span><br><span class="line">　private StringBuffer currentObj;//该对象池当前可以借出的对象</span><br><span class="line">　private Vector pool;//用于存放对象的池</span><br><span class="line">　public ObjectPool(ParameterObject paraObj) &#123;</span><br><span class="line">　　this.paraObj = paraObj;</span><br><span class="line">　　pool = new Vector();</span><br><span class="line">　&#125;</span><br><span class="line">　public StringBuffer <span class="function"><span class="title">getObject</span></span>() &#123;</span><br><span class="line">　　<span class="keyword">if</span> (pool.size() &lt;= paraObj.getM<span class="keyword">in</span>Count()) &#123;</span><br><span class="line">　　　<span class="keyword">if</span> (currentNum &lt;= paraObj.getMaxCount()) &#123;</span><br><span class="line">　　　　currentObj = new StringBuffer();</span><br><span class="line">　　　　currentNum++;</span><br><span class="line">　　　&#125; </span><br><span class="line">　　　. . . </span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="built_in">return</span> currentObj;</span><br><span class="line">　&#125;</span><br><span class="line">　public void <span class="built_in">return</span>Object(Object obj) &#123;</span><br><span class="line">　　// 确保对象具有正确的类型</span><br><span class="line">　　<span class="keyword">if</span> (StringBuffer.isInstance(obj)) &#123;</span><br><span class="line">　　　. . . </span><br><span class="line">　　&#125;</span><br><span class="line">　&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结</p>
<p>　　恰当地使用对象池技术，能有效地改善应用程序的性能。目前，对象池技术已得到广泛的应用，如对于网络和数据库连接这类重量级的对象，一般都会采用对象池技术。但在使用对象池技术时也要注意如下问题： </p>
<p>　　并非任何情况下都适合采用对象池技术。基本上，只在重复生成某种对象的操作成为影响性能的关键因素的时候，才适合采用对象池技术。而如果进行池化所能带来的性能提高并不重要的话，还是不采用对象池化技术为佳，以保持代码的简明。</p>
<p>　　要根据具体情况正确选择对象池的实现方式。如果是创建一个公用的对象池技术实现包，或需要在程序中动态指定所池化对象的Class类型时，才选择通用对象池。而大部分情况下，采用专用对象池就可以了。</p>
<p>转自:<a href="http://dev.yesky.com/421/2685421.shtml" target="_blank" rel="external">http://dev.yesky.com/421/2685421.shtml</a></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/技术/">技术</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/java-高级/">java 高级</a>, <a href="/tags/分享/">分享</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-03-27T14:37:08.000Z"><a href="/2016/03/27/spring-aop相关术语/">2016-03-27</a></time>
      
      
  
    <h1 class="title"><a href="/2016/03/27/spring-aop相关术语/">spring-aop相关术语</a></h1>
  

    </header>
    <div class="entry">
      
        <p>aop是采取的横向抽取的机制，取代了传统的取代了传统的纵向继承体系。<br>由于继承，会产生很多的侵入式代码复用，所以我们使用了横向的抽取机制（aop方式），这就是所谓的不需要修改原来的代码，只是通过代理对原来的功能进行增强。这种机制运用的就是代理。</p>
<p>JointPoint:连接点。指所有被拦截到的点。因为代理对象会对被代理目标对象的所有方法进行拦截，所以，被代理对象的所有方法都是连接点。</p>
<p>PointCut ：切入点，只spring配置中，指明对那几个方法起拦截作用，这几个点就是切入点。</p>
<p>Advice ： 通知、也叫作增强，指对目标方法的增强代码。</p>
<p>Intruction： 引介，这是一种特殊的Advice，但是引介不是对方法的增强，而是对类的增强，比如对某一个类增加属性或者方法。</p>
<p>Target：目标对象，指被拦截的对象。</p>
<p>Weaving：织入，指的是将advice 应用到 target的过程。</p>
<p>Aspect：切面，是切点和通知的结合。通常一个切面可以包含多个切点和多个通知。</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/技术/">技术</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/spring/">spring</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-03-24T03:44:33.000Z"><a href="/2016/03/24/主副线程的交替打印（多线程编程）/">2016-03-24</a></time>
      
      
  
    <h1 class="title"><a href="/2016/03/24/主副线程的交替打印（多线程编程）/">主副线程的交替运行(多线程编程)</a></h1>
  

    </header>
    <div class="entry">
      
        <p>实现下列需求：<br>子线程循环10次，接着主线程循环100次，接着又回到子线程循环10次，接着又回到主线程循环100次，如此循环100次。</p>
<p>代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package cn.cqupt.check;</span><br><span class="line"></span><br><span class="line">public class TestThread2 &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new TestThread2().init();</span><br><span class="line">	&#125;</span><br><span class="line">	public void <span class="function"><span class="title">init</span></span>() &#123;</span><br><span class="line">		final Business business = new Business();</span><br><span class="line">		new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</span><br><span class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">				<span class="keyword">for</span>(int i =0;i &lt; 50 ; i++) &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						business.subThread(i);</span><br><span class="line">					&#125; catch (InterruptedException e) &#123;</span><br><span class="line">						// TODO Auto-generated catch block</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">		<span class="keyword">for</span>(int i = 0; i&lt;50; i ++) &#123;</span><br><span class="line">			try &#123;</span><br><span class="line">				business.mainThread(i);</span><br><span class="line">			&#125; catch (InterruptedException e) &#123;</span><br><span class="line">				// TODO Auto-generated catch block</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	private class Business &#123;</span><br><span class="line">		boolean bShouldSub = <span class="literal">true</span>;</span><br><span class="line">		public synchronized void mainThread(int i) throws InterruptedException &#123;</span><br><span class="line">			<span class="keyword">if</span>(bShouldSub) &#123;</span><br><span class="line">				this.wait();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(int j = 0; j &lt; 100;j++ ) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">"i="</span> + i+<span class="string">", j="</span> +j);</span><br><span class="line">			&#125;</span><br><span class="line">			bShouldSub = <span class="literal">true</span>;</span><br><span class="line">			this.notify();</span><br><span class="line">		&#125;</span><br><span class="line">		public synchronized void subThread(int i) throws InterruptedException &#123;</span><br><span class="line">			<span class="keyword">if</span>(!bShouldSub) &#123;</span><br><span class="line">				this.wait();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(int j = 0; j &lt; 10;j++ ) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">"i="</span> + i+<span class="string">", j="</span> +j);</span><br><span class="line">			&#125;</span><br><span class="line">			bShouldSub = <span class="literal">false</span>;</span><br><span class="line">			this.notify();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/技术/">技术</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/分享/">分享</a>, <a href="/tags/多线程编程/">多线程编程</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-03-24T02:27:27.000Z"><a href="/2016/03/24/多线程的几种方法？同步的几种方法？/">2016-03-24</a></time>
      
      
  
    <h1 class="title"><a href="/2016/03/24/多线程的几种方法？同步的几种方法？/">多线程的几种方法？同步的几种方法？</a></h1>
  

    </header>
    <div class="entry">
      
        <p>多线程的实现的三种方法；<br>1 实现Runnable接口<br>代码如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new Thread(new <span class="function"><span class="title">Runnable</span></span>() &#123;</span><br><span class="line">	public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">		//填入线程要执行的代码</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></p>
<p>2 继承Thread对象，重写里边的Runnable方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyThread extends Thread &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">		//填入线程要执行的方法</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">new Myhread().start();//启动线程</span><br></pre></td></tr></table></figure></p>
<p>3 实现Callable接口，并用FutureTask 包装器封装成task兑现，交给Thread执行即可:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.current.*;</span><br><span class="line">class MyCounter implements Callable&lt;Integer&gt; &#123;</span><br><span class="line">	//重写call方法</span><br><span class="line">	public Integer <span class="function"><span class="title">call</span></span>() &#123;</span><br><span class="line">		//填入线程要执行的方法</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">//实现该类</span><br><span class="line">public class Test &#123;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		MyCounter mc = new MyCounter();</span><br><span class="line">		FutureTask&lt;Integer&gt; task  = new FutureTask&lt;Integer&gt;(mc);//封装成task任务</span><br><span class="line">		Thread  t = new Thread(task);</span><br><span class="line">		t.start();//启动线程</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同步的几种方法：<br>同步的实现方法有两种：分别是synchronized，wait与notify<br>wait():使一个线程处于等待状态，并释放所有的锁<br>sleep():使一个正在运行的线程处于休眠状态，是Thread的静态方法，调用该方法要捕捉InterruptedException（中断异常）异常，调用该方法进入休眠状态的线程，不需要使用notify或者notifyAll方法唤醒，并且notify或者notifyAll方法也不能唤醒此类线程。<br>notify():唤醒一个处于等待状态的线程，注意是在调用该方法的时候，并不能确定唤醒的是哪一个线程，而是由JVM确定唤醒的是哪个线程，而且不是按照优先级。<br>notifyAll():唤醒所有的等待线程，注意不是给所有的线程一个锁，而是让他们竞争锁。</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/技术/">技术</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/java基础/">java基础</a>, <a href="/tags/多线程编程/">多线程编程</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-03-23T14:38:42.000Z"><a href="/2016/03/23/java8特性介绍(转载)/">2016-03-23</a></time>
      
      
  
    <h1 class="title"><a href="/2016/03/23/java8特性介绍(转载)/">java8特性介绍(转载)</a></h1>
  

    </header>
    <div class="entry">
      
        <p>这次博客推荐的java8的十大新特性，并将使用简单的代码示例来指你如何使用默认接口方法。比如流，函数式接口，Map以及全新的日期API</p>
<p>本教程将用带注释的简单代码来描述新特性，你将看不到大片吓人的文字。<br>一 接口额默认方法</p>
<p>java8 允许我们给接口添加一个非抽象的方法实现，只需要使用default关键字即可，这个特性又叫做扩展方法，代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">interface Formula &#123;</span><br><span class="line">	double calculate(int a );</span><br><span class="line">	default double sqrt(int a) &#123;</span><br><span class="line">		retuen Math.squrt(a);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。<br>代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Formaula formula = new <span class="function"><span class="title">Formula</span></span>() &#123;</span><br><span class="line">	@Override</span><br><span class="line">	public double caculate(int a) &#123;</span><br><span class="line">		<span class="built_in">return</span> squart(a * 100);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;；</span><br><span class="line">formula.caculate(100);//100.0</span><br><span class="line">formula.sqrt(16);//4.0</span><br></pre></td></tr></table></figure></p>
<p>文中的formula被实现为一个匿名类的实例，该代码非常容易理解，6行代码实现了计算 sqrt(a * 100)。在下一节中，我们将会看到实现单方法接口的更简单的做法。</p>
<p>译者注： 在Java中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现，在C++中支持多继承，允许一个子类同时具有多个父类的接口与功能，在其他语言中，让一个类同时具有其他的可复用代码的方法叫做mixin。新的Java 8 的这个特新在编译器实现的角度上来说更加接近Scala的trait。 在C#中也有名为扩展方法的概念，允许给已存在的类型扩展方法，和Java 8的这个在语义上有差别。</p>
<p>二、Lambda 表达式</p>
<p>首先看看在老版本的Java中是如何排列字符串的：<br>代码如下：<br>List<string> names = Arrays.aslist(“peter”,”anna,”mike”,”xenia”);</string></p>
<p>Collections.sort(names,new Comparator<string>() {<br>    @Override<br>    public int compare(String a,String b) {<br>        return b.compareTo(a);<br>    }<br>});<br>只需要给静态方法 Collections.sort 传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。</string></p>
<p>在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection.sort(names,(String a, String b) -&gt; <span class="built_in">return</span> b.compareTo(a));</span><br></pre></td></tr></table></figure></p>
<p>看到了吧，代码变得更段且更具有可读性，但是实际上还可以写得更短：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure></p>
<p>对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(names, (a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure></p>
<p>Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还能作出什么更方便的东西来：</p>
<p>三、函数式接口</p>
<p>Lambda表达式是如何在java的类型系统中表示的呢？每一个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为 默认方法 不算抽象方法，所以你也可以给你的函数式接口添加默认方法。</p>
<p>我们可以将lambda表达式当作任意只包含一个抽象方法的接口类型，确保你的接口一定达到这个要求，你只需要给你的接口添加 @FunctionalInterface 注解，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface Converter&lt;F, T&gt; &#123;</span><br><span class="line">    T convert(F from);</span><br><span class="line">&#125;</span><br><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(converted);    // 123</span><br></pre></td></tr></table></figure></p>
<p>需要注意如果@FunctionalInterface如果没有指定，上面的代码也是对的。</p>
<p>译者注 将lambda表达式映射到一个单方法的接口上，这种做法在Java 8之前就有别的语言实现，比如Rhino JavaScript解释器，如果一个函数参数接收一个单方法的接口而你传递的是一个function，Rhino 解释器会自动做一个单接口的实例到function的适配器，典型的应用场景有 org.w3c.dom.events.EventTarget 的addEventListener 第二个参数 EventListener。</p>
<p>四、方法与构造函数引用</p>
<p>前一节中的代码还可以通过静态方法引用来表示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</span><br><span class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(converted);   // 123</span><br></pre></td></tr></table></figure></p>
<p>Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">converter = something::startsWith;</span><br><span class="line">String converted = converter.convert(<span class="string">"Java"</span>);</span><br><span class="line">System.out.println(converted);    // <span class="string">"J"</span></span><br></pre></td></tr></table></figure>
<p>接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    String firstName;</span><br><span class="line">    String lastName;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="title">Person</span></span>() &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    Person(String firstName, String lastName) &#123;</span><br><span class="line">        this.firstName = firstName;</span><br><span class="line">        this.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来我们指定一个用来创建Person对象的对象工厂接口：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">interface PersonFactory&lt;P extends Person&gt; &#123;</span><br><span class="line">    P create(String firstName, String lastName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PersonFactory&lt;Person&gt; personFactory = Person::new;</span><br><span class="line">Person person = personFactory.create(<span class="string">"Peter"</span>, <span class="string">"Parker"</span>);</span><br></pre></td></tr></table></figure></p>
<p>我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。</p>
<p>五、Lambda 作用域</p>
<p>在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。</p>
<p>六、访问局部变量</p>
<p>我们可以直接在lambda表达式中访问外层的局部变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">final int num = 1;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num);</span><br><span class="line"> </span><br><span class="line">stringConverter.convert(2);     // 3</span><br></pre></td></tr></table></figure>
<p>但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int num = 1;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line"> </span><br><span class="line">stringConverter.convert(2);     // 3</span><br></pre></td></tr></table></figure></p>
<p>不过这里的num必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int num = 1;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line">num = 3;</span><br></pre></td></tr></table></figure></p>
<p>在lambda表达式中试图修改num同样是不允许的。</p>
<p>七、访问对象字段与静态变量</p>
<p>和本地变量不同的是，lambda内部对于实例的字段以及静态变量是即可读又可写。该行为和匿名对象是一致的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Lambda4 &#123;</span><br><span class="line">    static int outerStaticNum;</span><br><span class="line">    int outerNum;</span><br><span class="line"> </span><br><span class="line">    void <span class="function"><span class="title">testScopes</span></span>() &#123;</span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;</span><br><span class="line">            outerNum = 23;</span><br><span class="line">            <span class="built_in">return</span> String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line"> </span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;</span><br><span class="line">            outerStaticNum = 72;</span><br><span class="line">            <span class="built_in">return</span> String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>八、访问接口的默认方法</p>
<p>还记得第一节中的formula例子么，接口Formula定义了一个默认方法sqrt可以直接被formula的实例包括匿名对象访问到，但是在lambda表达式中这个是不行的。<br>Lambda表达式中是无法访问到默认方法的，以下代码将无法编译：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = (a) -&gt; sqrt( a * 100);</span><br><span class="line">Built-in Functional Interfaces</span><br></pre></td></tr></table></figure></p>
<p>JDK 1.8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。<br>Java 8 API同样还提供了很多全新的函数式接口来让工作更加方便，有一些接口是来自Google Guava库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。</p>
<p>Predicate接口</p>
<p>Predicate 接口只有一个参数，返回boolean类型。该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0;</span><br><span class="line"> </span><br><span class="line">predicate.test(<span class="string">"foo"</span>);              // <span class="literal">true</span></span><br><span class="line">predicate.negate().test(<span class="string">"foo"</span>);     // <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</span><br><span class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</span><br><span class="line"> </span><br><span class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</span><br><span class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</span><br></pre></td></tr></table></figure>
<p>Function 接口</p>
<p>Function 接口有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法（compose, andThen）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</span><br><span class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</span><br><span class="line"> </span><br><span class="line">backToString.apply(<span class="string">"123"</span>);     // <span class="string">"123"</span></span><br></pre></td></tr></table></figure>
<p>Supplier 接口</p>
<p>Supplier 接口返回一个任意范型的值，和Function接口不同的是该接口没有任何参数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = Person::new;</span><br><span class="line">personSupplier.get();   // new Person</span><br></pre></td></tr></table></figure></p>
<p>Consumer 接口</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(<span class="string">"Hello, "</span> + p.firstName);</span><br><span class="line">greeter.accept(new Person(<span class="string">"Luke"</span>, <span class="string">"Skywalker"</span>));</span><br></pre></td></tr></table></figure>
<p>Comparator 接口</p>
<p>Comparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</span><br><span class="line"> </span><br><span class="line">Person p1 = new Person(<span class="string">"John"</span>, <span class="string">"Doe"</span>);</span><br><span class="line">Person p2 = new Person(<span class="string">"Alice"</span>, <span class="string">"Wonderland"</span>);</span><br><span class="line"> </span><br><span class="line">comparator.compare(p1, p2);             // &gt; 0</span><br><span class="line">comparator.reversed().compare(p1, p2);  // &lt; 0</span><br></pre></td></tr></table></figure>
<p>Optional 接口</p>
<p>Optional 不是函数是接口，这是个用来防止NullPointerException异常的辅助类型，这是下一届中将要用到的重要概念，现在先简单的看看这个接口能干什么：</p>
<p>Optional 被定义为一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java 8中，不推荐你返回null而是返回Optional。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">"bam"</span>);</span><br><span class="line"> </span><br><span class="line">optional.isPresent();           // <span class="literal">true</span></span><br><span class="line">optional.get();                 // <span class="string">"bam"</span></span><br><span class="line">optional.orElse(<span class="string">"fallback"</span>);    // <span class="string">"bam"</span></span><br><span class="line"> </span><br><span class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(0)));     // <span class="string">"b"</span></span><br></pre></td></tr></table></figure></p>
<p>Stream 接口</p>
<p>java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如 java.util.Collection的子类，List或者Set， Map不支持。Stream的操作可以串行执行或者并行执行。</p>
<p>首先看看Stream是怎么用，首先创建实例代码的用到的数据List：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();</span><br><span class="line">stringCollection.add(<span class="string">"ddd2"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"aaa2"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"bbb1"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"aaa1"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"bbb3"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"ccc"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"bbb2"</span>);</span><br><span class="line">stringCollection.add(<span class="string">"ddd1"</span>);</span><br></pre></td></tr></table></figure></p>
<p>Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作<br>Filter 过滤</p>
<p>过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(<span class="string">"a"</span>))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"> </span><br><span class="line">// <span class="string">"aaa2"</span>, <span class="string">"aaa1"</span></span><br></pre></td></tr></table></figure>
<p>Sort 排序</p>
<p>排序是一个中间操作，返回的是排序好后的Stream。如果你不指定一个自定义的Comparator则会使用默认排序。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .sorted()</span><br><span class="line">    .filter((s) -&gt; s.startsWith(<span class="string">"a"</span>))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"> </span><br><span class="line">// <span class="string">"aaa1"</span>, <span class="string">"aaa2"</span></span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(stringCollection);</span><br><span class="line">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</span><br></pre></td></tr></table></figure></p>
<p>Map 映射</p>
<p>中间操作map会将元素根据指定的Function接口来依次将元素转成另外的对象，下面的示例展示了将字符串转换为大写字符串。你也可以通过map来讲对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stringCollection</span><br><span class="line">    .stream()</span><br><span class="line">    .map(String::toUpperCase)</span><br><span class="line">    .sorted((a, b) -&gt; b.compareTo(a))</span><br><span class="line">    .forEach(System.out::println);</span><br><span class="line"> </span><br><span class="line">// <span class="string">"DDD2"</span>, <span class="string">"DDD1"</span>, <span class="string">"CCC"</span>, <span class="string">"BBB3"</span>, <span class="string">"BBB2"</span>, <span class="string">"AAA2"</span>, <span class="string">"AAA1"</span></span><br></pre></td></tr></table></figure>
<p>Match 匹配</p>
<p>Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是最终操作，并返回一个boolean类型的值。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">boolean anyStartsWithA = </span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .anyMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</span><br><span class="line"> </span><br><span class="line">System.out.println(anyStartsWithA);      // <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line">boolean allStartsWithA = </span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .allMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</span><br><span class="line"> </span><br><span class="line">System.out.println(allStartsWithA);      // <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line">boolean noneStartsWithZ = </span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .noneMatch((s) -&gt; s.startsWith(<span class="string">"z"</span>));</span><br><span class="line"> </span><br><span class="line">System.out.println(noneStartsWithZ);      // <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>Count 计数</p>
<p>计数是一个最终操作，返回Stream中元素的个数，返回值类型是long。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">long startsWithB = </span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .filter((s) -&gt; s.startsWith(<span class="string">"b"</span>))</span><br><span class="line">        .count();</span><br><span class="line"> </span><br><span class="line">System.out.println(startsWithB);    // 3</span><br></pre></td></tr></table></figure></p>
<p>Reduce 规约</p>
<p>这是一个最终操作，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Optional&lt;String&gt; reduced =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .sorted()</span><br><span class="line">        .reduce((s1, s2) -&gt; s1 + <span class="string">"#"</span> + s2);</span><br><span class="line"> </span><br><span class="line">reduced.ifPresent(System.out::println);</span><br><span class="line">// <span class="string">"aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2"</span></span><br></pre></td></tr></table></figure></p>
<p>并行Streams</p>
<p>前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。</p>
<p>下面的例子展示了是如何通过并行Stream来提升性能：</p>
<p>首先我们创建一个没有重复元素的大表：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int max = 1000000;</span><br><span class="line">List&lt;String&gt; values = new ArrayList&lt;&gt;(max);</span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; max; i++) &#123;</span><br><span class="line">    UUID uuid = UUID.randomUUID();</span><br><span class="line">    values.add(uuid.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们计算一下排序这个Stream要耗时多久，<br>串行排序：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">long t0 = System.nanoTime();</span><br><span class="line"> </span><br><span class="line">long count = values.stream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"> </span><br><span class="line">long t1 = System.nanoTime();</span><br><span class="line"> </span><br><span class="line">long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">"sequential sort took: %d ms"</span>, millis));</span><br></pre></td></tr></table></figure></p>
<p>// 串行耗时: 899 ms<br>并行排序：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">long t0 = System.nanoTime();</span><br><span class="line"> </span><br><span class="line">long count = values.parallelStream().sorted().count();</span><br><span class="line">System.out.println(count);</span><br><span class="line"> </span><br><span class="line">long t1 = System.nanoTime();</span><br><span class="line"> </span><br><span class="line">long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</span><br><span class="line">System.out.println(String.format(<span class="string">"parallel sort took: %d ms"</span>, millis));</span><br></pre></td></tr></table></figure></p>
<p>// 并行排序耗时: 472 ms<br>上面两个代码几乎是一样的，但是并行版的快了50%之多，唯一需要做的改动就是将stream()改为parallelStream()。</p>
<p>Map</p>
<p>前面提到过，Map类型不支持stream，不过Map提供了一些新的有用的方法来处理一些日常任务。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">    map.putIfAbsent(i, <span class="string">"val"</span> + i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>map.forEach((id, val) -&gt; System.out.println(val));<br>以上代码很容易理解， putIfAbsent 不需要我们做额外的存在性检查，而forEach则接收一个Consumer接口来对map里的每一个键值对进行操作。</p>
<p>下面的例子展示了map上的其他有用的函数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">map.computeIfPresent(3, (num, val) -&gt; val + num);</span><br><span class="line">map.get(3);             // val33</span><br><span class="line"> </span><br><span class="line">map.computeIfPresent(9, (num, val) -&gt; null);</span><br><span class="line">map.containsKey(9);     // <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line">map.computeIfAbsent(23, num -&gt; <span class="string">"val"</span> + num);</span><br><span class="line">map.containsKey(23);    // <span class="literal">true</span></span><br><span class="line"> </span><br><span class="line">map.computeIfAbsent(3, num -&gt; <span class="string">"bam"</span>);</span><br><span class="line">map.get(3);             // val33</span><br></pre></td></tr></table></figure>
<p>接下来展示如何在Map里删除一个键值全都匹配的项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map.remove(3, <span class="string">"val3"</span>);</span><br><span class="line">map.get(3);             // val33</span><br><span class="line"> </span><br><span class="line">map.remove(3, <span class="string">"val33"</span>);</span><br><span class="line">map.get(3);             // null</span><br></pre></td></tr></table></figure></p>
<p>另外一个有用的方法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.getOrDefault(42, <span class="string">"not found"</span>);  // not found</span><br></pre></td></tr></table></figure></p>
<p>对Map的元素做合并也变得很容易了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map.merge(9, <span class="string">"val9"</span>, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(9);             // val9</span><br><span class="line"> </span><br><span class="line">map.merge(9, <span class="string">"concat"</span>, (value, newValue) -&gt; value.concat(newValue));</span><br><span class="line">map.get(9);             // val9concat</span><br></pre></td></tr></table></figure>
<p>Merge做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。</p>
<p>九、Date API</p>
<p>Java 8 在包java.time下包含了一组全新的时间日期API。新的日期API和开源的Joda-Time库差不多，但又不完全一样，下面的例子展示了这组新API里最重要的一些部分：</p>
<p>Clock 时钟</p>
<p>Clock类提供了访问当前日期和时间的方法，Clock是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用Instant类来表示，Instant类也可以用来创建老的java.util.Date对象。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Clock clock = Clock.systemDefaultZone();</span><br><span class="line">long millis = clock.millis();</span><br><span class="line"> </span><br><span class="line">Instant instant = clock.instant();</span><br><span class="line">Date legacyDate = Date.from(instant);   // legacy java.util.Date</span><br></pre></td></tr></table></figure></p>
<p>Timezones 时区</p>
<p>在新API中时区使用ZoneId来表示。时区可以很方便的使用静态方法of来获取到。 时区定义了到UTS时间的时间差，在Instant时间点对象到本地日期对象之间转换的时候是极其重要的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">System.out.println(ZoneId.getAvailableZoneIds());</span><br><span class="line">// prints all available timezone ids</span><br><span class="line"> </span><br><span class="line">ZoneId zone1 = ZoneId.of(<span class="string">"Europe/Berlin"</span>);</span><br><span class="line">ZoneId zone2 = ZoneId.of(<span class="string">"Brazil/East"</span>);</span><br><span class="line">System.out.println(zone1.getRules());</span><br><span class="line">System.out.println(zone2.getRules());</span><br><span class="line"> </span><br><span class="line">// ZoneRules[currentStandardOffset=+01:00]</span><br><span class="line">// ZoneRules[currentStandardOffset=-03:00]</span><br></pre></td></tr></table></figure>
<p>LocalTime 本地时间</p>
<p>LocalTime 定义了一个没有时区信息的时间，例如 晚上10点，或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LocalTime now1 = LocalTime.now(zone1);</span><br><span class="line">LocalTime now2 = LocalTime.now(zone2);</span><br><span class="line"> </span><br><span class="line">System.out.println(now1.isBefore(now2));  // <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line">long hoursBetween = ChronoUnit.HOURS.between(now1, now2);</span><br><span class="line">long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</span><br><span class="line"> </span><br><span class="line">System.out.println(hoursBetween);       // -3</span><br><span class="line">System.out.println(minutesBetween);     // -239</span><br></pre></td></tr></table></figure>
<p>LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LocalTime late = LocalTime.of(23, 59, 59);</span><br><span class="line">System.out.println(late);       // 23:59:59</span><br><span class="line"> </span><br><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofLocalizedTime(FormatStyle.SHORT)</span><br><span class="line">        .withLocale(Locale.GERMAN);</span><br><span class="line"> </span><br><span class="line">LocalTime leetTime = LocalTime.parse(<span class="string">"13:37"</span>, germanFormatter);</span><br><span class="line">System.out.println(leetTime);   // 13:37</span><br></pre></td></tr></table></figure></p>
<p>LocalDate 本地日期</p>
<p>LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);</span><br><span class="line">LocalDate yesterday = tomorrow.minusDays(2);</span><br><span class="line"> </span><br><span class="line">LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);</span><br><span class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</span><br></pre></td></tr></table></figure></p>
<p>System.out.println(dayOfWeek);    // FRIDAY<br>从字符串解析一个LocalDate类型和解析LocalTime一样简单：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofLocalizedDate(FormatStyle.MEDIUM)</span><br><span class="line">        .withLocale(Locale.GERMAN);</span><br><span class="line"> </span><br><span class="line">LocalDate xmas = LocalDate.parse(<span class="string">"24.12.2014"</span>, germanFormatter);</span><br><span class="line">System.out.println(xmas);   // 2014-12-24</span><br></pre></td></tr></table></figure></p>
<p>LocalDateTime 本地日期时间</p>
<p>LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime和LocalTime还有LocalDate一样，都是不可变的。LocalDateTime提供了一些能访问具体字段的方法。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);</span><br><span class="line"> </span><br><span class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);      // WEDNESDAY</span><br><span class="line"> </span><br><span class="line">Month month = sylvester.getMonth();</span><br><span class="line">System.out.println(month);          // DECEMBER</span><br><span class="line"> </span><br><span class="line">long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</span><br><span class="line">System.out.println(minuteOfDay);    // 1439</span><br></pre></td></tr></table></figure></p>
<p>只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Instant instant = sylvester</span><br><span class="line">        .atZone(ZoneId.systemDefault())</span><br><span class="line">        .toInstant();</span><br><span class="line"> </span><br><span class="line">Date legacyDate = Date.from(instant);</span><br><span class="line">System.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014</span><br></pre></td></tr></table></figure></p>
<p>格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofPattern(<span class="string">"MMM dd, yyyy - HH:mm"</span>);</span><br><span class="line"> </span><br><span class="line">LocalDateTime parsed = LocalDateTime.parse(<span class="string">"Nov 03, 2014 - 07:13"</span>, formatter);</span><br><span class="line">String string = formatter.format(parsed);</span><br><span class="line">System.out.println(string);     // Nov 03, 2014 - 07:13</span><br></pre></td></tr></table></figure>
<p>和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。<br>关于时间日期格式的详细信息：<a href="http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html" target="_blank" rel="external">http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html</a></p>
<p>十、Annotation 注解<br>在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。<br>首先定义一个包装类Hints注解用来放置一组具体的Hint注解：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface Hints &#123;</span><br><span class="line">    Hint[] value();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">@Repeatable(Hints.class)</span><br><span class="line">@interface Hint &#123;</span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。</p>
<p>例 1: 使用包装类当容器来存多个注解（老方法）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Hints(&#123;@Hint(<span class="string">"hint1"</span>), @Hint(<span class="string">"hint2"</span>)&#125;)</span><br><span class="line">class Person &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>例 2：使用多重注解（新方法）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@Hint(<span class="string">"hint1"</span>)</span><br><span class="line">@Hint(<span class="string">"hint2"</span>)</span><br><span class="line">class Person &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你<br>用反射来获取这些信息：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Hint hint = Person.class.getAnnotation(Hint.class);</span><br><span class="line">System.out.println(hint);                   // null</span><br><span class="line"> </span><br><span class="line">Hints hints1 = Person.class.getAnnotation(Hints.class);</span><br><span class="line">System.out.println(hints1.value().length);  // 2</span><br><span class="line"> </span><br><span class="line">Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);</span><br><span class="line">System.out.println(hints2.length);          // 2</span><br></pre></td></tr></table></figure></p>
<p>即便我们没有在Person类上定义@Hints注解，我们还是可以通过 getAnnotation(Hints.class) 来获取 @Hints注解，更加方便的方法是使用 getAnnotationsByType 可以直接获取到所有的@Hint注解。<br>另外Java 8的注解还增加到两种新的target上了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)</span><br><span class="line">@interface MyAnnotation &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>关于Java 8的新特性就写到这了，肯定还有更多的特性等待发掘。JDK 1.8里还有很多很有用的东西，比如Arrays.parallelSort, StampedLock和CompletableFuture等等。</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/技术/">技术</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/java-新知/">java 新知</a>, <a href="/tags/概念/">概念</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-03-21T17:25:25.000Z"><a href="/2016/03/22/java中Sort方法底层实现/">2016-03-22</a></time>
      
      
  
    <h1 class="title"><a href="/2016/03/22/java中Sort方法底层实现/">java中Sort方法底层实现</a></h1>
  

    </header>
    <div class="entry">
      
        <p>java中Arrays.sort使用了两种排序方法，快速排序和优化的合并排序。<br>快速排序主要是对哪些基本类型数据（int,short,long等）排序， 而合并排序用于对对象类型进行排序。<br>使用不同类型的排序算法主要是由于快速排序是不稳定的，而合并排序是稳定的。这里的稳定是指比较相等的数据在排序之后仍然按照排序之前的前后顺序排列。对于基本数据类型，稳定性没有意义，而对于对象类型，稳定性是比较重要的，因为对象相等的判断可能只是判断关键属性，最好保持相等对象的非关键属性的顺序与排序前一直；另外一个原因是由于合并排序相对而言比较次数比快速排序少，移动（对象引用的移动）次数比快速排序多，而对于对象来说，比较一般比移动耗时。<br>补充一点合并排序的时间复杂度是n<em>logn, 快速排序的平均时间复杂度也是n</em>logn，但是合并排序的需要额外的n个引用的空间 ……<br>转自：<a href="http://blog.sina.com.cn/s/blog_7337d6a00100xpd5.html" target="_blank" rel="external">http://blog.sina.com.cn/s/blog_7337d6a00100xpd5.html</a></p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/技术/">技术</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/java基础/">java基础</a>, <a href="/tags/算法/">算法</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-03-21T14:16:13.000Z"><a href="/2016/03/21/ArrayList和Vector的区别/">2016-03-21</a></time>
      
      
  
    <h1 class="title"><a href="/2016/03/21/ArrayList和Vector的区别/">ArrayList和Vector的区别</a></h1>
  

    </header>
    <div class="entry">
      
        <p>这两个类都实现了List接口（List接口继承了Collection接口），他们都是有序集合，级存贮在这两个集合中的元素都是有序的，他们的底层实现就是用数组。我们可以按照集合中元素的索引号取出某个元素，并且其中元素是可以重复的（比较和HashTable以及HashMap的区别）。</p>
<p>接下来我们详细说明两者的区别：<br>1 同步性<br>    Vector是线程安全的，也就是说他的方法之间是线程同步的，而Arraylist是线程不安全的，他的方法之间不是线程同步的，如果只有一个线程会访问到集合，那么我们就应该用ArrayList，因为他不需要考虑线程的安全性，效率更高；如果有多个线程访问该集合，那么最好使用Vector，因为他是贤臣安全的，我们就不要在考虑和编写线程安全的代码。<br>2 数据增长<br>    Arraylist与Vector都有一个初始的容量大小，当存储在他们里边的元素的个数超过了该容量，就需要增加ArrayList和Vector的大小，每次要增加存储空间的时候，不是增加一个存储空间，而是增加多个存储空间，Vector增加默认增加为原来的两倍，Arraylist增加为原来的1.5倍（在源码中可以看到）。他们也可以设置增长空间大小，比如用resize方法</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/技术/">技术</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/java基础/">java基础</a>, <a href="/tags/Collection/">Collection</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>





  <article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-03-21T13:39:00.000Z"><a href="/2016/03/21/Comparable和Comparator的区别/">2016-03-21</a></time>
      
      
  
    <h1 class="title"><a href="/2016/03/21/Comparable和Comparator的区别/">Comparable和Comparator的区别</a></h1>
  

    </header>
    <div class="entry">
      
        <p>Comparator和Comparable 都是用来实现集合中元素的比较。排序的，知识，Comparable实现的排序实在java集合内部实现的，而Comparator的排序实在java集合外部实现的排序，所以，如果想实现排序，那就需要在集合内实现Comparable接口或者在集合外部实现Comparator接口</p>
<p>另外，就从所处的包来说： Comparator位于java.util下，而Comparable位于包java.lang下</p>
<p>下边我们详细说下两者的异同：<br>1 Comaprable和Comaprator相同的地方<br>他们都是一个java接口，并且都是用来对定义的class比较大小的，什么是是自定义的class，如public class person {。。。}<br> 当我们有这么一个personList,里面包含了person1, person2, persion3….., 我们用Collections.sort( personList ),<br>是得不到预期的结果的. 这时肯定有人要问, 那为什么可以排序一个字符串list呢:</p>
<p>如 StringList{“hello1” , “hello3” , “hello2”}, Collections.sort( stringList ) 能够得到正确的排序, 那是因为<br>String 这个对象已经帮我们实现了 Comparable接口 , 所以我们的 Person 如果想排序, 也要实现一个比较器。</p>
<ol>
<li>Comparator 和 Comparable 的区别</li>
</ol>
<p>Comparable</p>
<p>Comparable 定义在 Person类的内部:</p>
<p>public class Persion implements Comparable {..比较Person的大小..},</p>
<p> 因为已经实现了比较器,那么我们的Person现在是一个可以比较大小的对象了,它的比较功能和String完全一样,可以随时随地的拿来<br>比较大小,因为Person现在自身就是有大小之分的。Collections.sort(personList)可以得到正确的结果。</p>
<p>Comparator</p>
<p>Comparator 是定义在Person的外部的, 此时我们的Person类的结构不需要有任何变化,如</p>
<p>public class Person{ String name; int age },</p>
<p>然后我们另外定义一个比较器:</p>
<p>public PersonComparator implements Comparator() {..比较Person的大小..},</p>
<p>在PersonComparator里面实现了怎么比较两个Person的大小. 所以,用这种方法,当我们要对一个 personList进行排序的时候,<br>我们除了了要传递personList过去, 还需要把PersonComparator传递过去,因为怎么比较Person的大小是在PersonComparator<br>里面实现的, 如:</p>
<p>Collections.sort( personList , new PersonComparator() ).</p>
<ol>
<li>Comparator 和 Comparable 的实例</li>
</ol>
<p>Comparable:</p>
<p>实现Comparable接口要覆盖compareTo方法, 在compareTo方法里面实现比较：<br>public class Person implements Comparable {<br>     String name;<br>     int age<br>     public int compareTo(Person another) {<br>          int i = 0;<br>          i = name.compareTo(another.name); // 使用字符串的比较<br>          if(i == 0) { // 如果名字一样,比较年龄, 返回比较年龄结果<br>               return age - another.age;<br>          } else {<br>               return i; // 名字不一样, 返回比较名字的结果.<br>          }<br>     }<br>}<br>   这时我们可以直接用 Collections.sort( personList ) 对其排序了.</p>
<p>Comparator:</p>
<p>实现Comparator需要覆盖 compare 方法：<br>public class Person{<br>     String name;<br>     int age<br>}</p>
<p>class PersonComparator implements Comparator {<br>     public int compare(Person one, Person another) {<br>          int i = 0;<br>          i = one.name.compareTo(another.name); // 使用字符串的比较<br>          if(i == 0) { // 如果名字一样,比较年龄,返回比较年龄结果<br>               return one.age - another.age;<br>          } else {<br>               return i; // 名字不一样, 返回比较名字的结果.<br>          }<br>     }<br>}<br>   Collections.sort( personList , new PersonComparator()) 可以对其排序</p>
<p> 4:总结</p>
<p>两种方法各有优劣, 用Comparable 简单, 只要实现Comparable 接口的对象直接就成为一个可以比较的对象,<br>但是需要修改源代码, 用Comparator 的好处是不需要修改源代码, 而是另外实现一个比较器, 当某个自定义<br>的对象需要作比较的时候,把比较器和对象一起传递过去就可以比大小了, 并且在Comparator 里面用户可以自<br>己实现复杂的可以通用的逻辑,使其可以匹配一些比较简单的对象,那样就可以节省很多重复劳动了。</p>

      
    </div>
    
    <footer>
        <div class="alignright">
          
          <a href='javascript:void(0)' class="share-link bdsharebuttonbox" data-cmd="more">分享</a>
        </div>
        
  
  <div class="categories">
    <a href="/categories/技术/">技术</a>
  </div>

        
  
  <div class="tags">
    <a href="/tags/java基础/">java基础</a>, <a href="/tags/Collection/">Collection</a>
  </div>

        <!-- partial('post/share') -->
      <div class="clearfix"></div>
    </footer>
  </div>
</article>






<nav id="pagination">
  
  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Nächste Seite &raquo;</a>
  </nav>

</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="Suche">
    <input type="hidden" name="q" value="site:yoursite.com">
  </form>
</div>

  
<div class="widget tag">
  <h3 class="title">Kategorien</h3>
  <ul class="entry">
  
    <li><a href="/categories/技术/">技术</a><small>13</small></li>
  
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">Neueste Artikel</h3>
  <ul class="entry">
    
      <li>
        <a href="/2016/04/11/java主函数所在类的思考/">java主函数所在类的思考</a>
      </li>
    
      <li>
        <a href="/2016/04/01/MySql外键设置中的Cascade-no-action-restrict-set-null-分享/">MySql外键设置中的Cascade, no action,restrict ,set null(分享)</a>
      </li>
    
      <li>
        <a href="/2016/03/30/Java对象池技术的原理及其实现-转载/">Java对象池技术的原理及其实现(转载)</a>
      </li>
    
      <li>
        <a href="/2016/03/27/spring-aop相关术语/">spring-aop相关术语</a>
      </li>
    
      <li>
        <a href="/2016/03/24/主副线程的交替打印（多线程编程）/">主副线程的交替运行(多线程编程)</a>
      </li>
    
  </ul>
</div>


  
<div class="widget tag">
  <h3 class="title">Tags</h3>
  <ul class="entry">
  
    <li><a href="/tags/Collection/">Collection</a><small>2</small></li>
  
    <li><a href="/tags/object-Object/">[object Object]</a><small>1</small></li>
  
    <li><a href="/tags/java-多线程编程/">java 多线程编程</a><small>1</small></li>
  
    <li><a href="/tags/java-新知/">java 新知</a><small>1</small></li>
  
    <li><a href="/tags/java-高级/">java 高级</a><small>1</small></li>
  
    <li><a href="/tags/java基础/">java基础</a><small>7</small></li>
  
    <li><a href="/tags/spring/">spring</a><small>1</small></li>
  
    <li><a href="/tags/分享/">分享</a><small>3</small></li>
  
    <li><a href="/tags/前端/">前端</a><small>1</small></li>
  
    <li><a href="/tags/后台/">后台</a><small>1</small></li>
  
    <li><a href="/tags/多线程编程/">多线程编程</a><small>2</small></li>
  
    <li><a href="/tags/技术/">技术</a><small>1</small></li>
  
    <li><a href="/tags/数据库/">数据库</a><small>1</small></li>
  
    <li><a href="/tags/概念/">概念</a><small>1</small></li>
  
    <li><a href="/tags/算法/">算法</a><small>1</small></li>
  
    <li><a href="/tags/随笔/">随笔</a><small>1</small></li>
  
  </ul>
</div>


  
<div class="widget tagcloud">
  <h3 class="title">Tag-Cloud</h3>
  <div class="entry">
    <a href="/tags/Collection/" style="font-size: 13.33px;">Collection</a> <a href="/tags/object-Object/" style="font-size: 10px;">[object Object]</a> <a href="/tags/java-多线程编程/" style="font-size: 10px;">java 多线程编程</a> <a href="/tags/java-新知/" style="font-size: 10px;">java 新知</a> <a href="/tags/java-高级/" style="font-size: 10px;">java 高级</a> <a href="/tags/java基础/" style="font-size: 20px;">java基础</a> <a href="/tags/spring/" style="font-size: 10px;">spring</a> <a href="/tags/分享/" style="font-size: 16.67px;">分享</a> <a href="/tags/前端/" style="font-size: 10px;">前端</a> <a href="/tags/后台/" style="font-size: 10px;">后台</a> <a href="/tags/多线程编程/" style="font-size: 13.33px;">多线程编程</a> <a href="/tags/技术/" style="font-size: 10px;">技术</a> <a href="/tags/数据库/" style="font-size: 10px;">数据库</a> <a href="/tags/概念/" style="font-size: 10px;">概念</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/随笔/" style="font-size: 10px;">随笔</a>
  </div>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  <p>
  
  &copy; 2016 Gengyukun
  
  All rights reserved.</p>
  <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</div>
<div class="clearfix"></div>

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script></footer>
  <script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>


<div id='bg'></div>
</body>
</html>